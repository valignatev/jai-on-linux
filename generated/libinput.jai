//
// This file was auto-generated using the following command:
//
// jai generate.jai
//



/**
* @ingroup base
* @struct libinput
*
* A handle for accessing libinput. This struct is refcounted, use
* libinput_ref() and libinput_unref().
*/
libinput :: struct {}

/**
* @ingroup device
* @struct libinput_device
*
* A base handle for accessing libinput devices. This struct is
* refcounted, use libinput_device_ref() and libinput_device_unref().
*/
libinput_device :: struct {}

/**
* @ingroup device
* @struct libinput_device_group
*
* A base handle for accessing libinput device groups. This struct is
* refcounted, use libinput_device_group_ref() and
* libinput_device_group_unref().
*/
libinput_device_group :: struct {}

/**
* @ingroup seat
* @struct libinput_seat
*
* The base handle for accessing libinput seats. This struct is
* refcounted, use libinput_seat_ref() and libinput_seat_unref().
*/
libinput_seat :: struct {}

/**
* @ingroup device
* @struct libinput_tablet_tool
*
* An object representing a tool being used by a device with the @ref
* LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
*
* Tablet events generated by such a device are bound to a specific tool
* rather than coming from the device directly. Depending on the hardware it
* is possible to track the same physical tool across multiple
* struct libinput_device devices.
* See libinput_tablet_tool_get_serial() for more details.
*
* This struct is refcounted, use libinput_tablet_tool_ref() and
* libinput_tablet_tool_unref().
*
* @since 1.2
*/
libinput_tablet_tool :: struct {}

/**
* @ingroup event
* @struct libinput_event
*
* The base event type. Use libinput_event_get_pointer_event() or similar to
* get the actual event type.
*
* @warning Unlike other structs events are considered transient and
* <b>not</b> refcounted.
*/
libinput_event :: struct {}

/**
* @ingroup event
* @struct libinput_event_device_notify
*
* An event notifying the caller of a device being added or removed.
*/
libinput_event_device_notify :: struct {}

/**
* @ingroup event_keyboard
* @struct libinput_event_keyboard
*
* A keyboard event representing a key press/release.
*/
libinput_event_keyboard :: struct {}

/**
* @ingroup event_pointer
* @struct libinput_event_pointer
*
* A pointer event representing relative or absolute pointer movement,
* a button press/release or scroll axis events.
*/
libinput_event_pointer :: struct {}

/**
* @ingroup event_touch
* @struct libinput_event_touch
*
* Touch event representing a touch down, move or up, as well as a touch
* cancel and touch frame events. Valid event types for this event are @ref
* LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_MOTION, @ref
* LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_CANCEL and @ref
* LIBINPUT_EVENT_TOUCH_FRAME.
*/
libinput_event_touch :: struct {}

/**
* @ingroup event_tablet
* @struct libinput_event_tablet_tool
*
* Tablet tool event representing an axis update, button press, or tool
* update. Valid event types for this event are @ref
* LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY and @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @since 1.2
*/
libinput_event_tablet_tool :: struct {}

/**
* @ingroup event_tablet_pad
* @struct libinput_event_tablet_pad
*
* Tablet pad event representing a button press, or ring/strip update on
* the tablet pad itself. Valid event types for this event are @ref
* LIBINPUT_EVENT_TABLET_PAD_BUTTON, @ref LIBINPUT_EVENT_TABLET_PAD_DIAL,
* @ref LIBINPUT_EVENT_TABLET_PAD_RING and
* @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.
*
* @since 1.3
*/
libinput_event_tablet_pad :: struct {}

/**
* @ingroup base
*
* Log priority for internal logging messages.
*/
libinput_log_priority :: enum u32 {
    DEBUG :: 10;
    INFO  :: 20;
    ERROR :: 30;

    LIBINPUT_LOG_PRIORITY_DEBUG :: DEBUG;
    LIBINPUT_LOG_PRIORITY_INFO  :: INFO;
    LIBINPUT_LOG_PRIORITY_ERROR :: ERROR;
}

/**
* @ingroup device
*
* Capabilities on a device. A device may have one or more capabilities
* at a time, capabilities remain static for the lifetime of the device.
*/
libinput_device_capability :: enum u32 {
    KEYBOARD    :: 0;
    POINTER     :: 1;
    TOUCH       :: 2;
    TABLET_TOOL :: 3;
    TABLET_PAD  :: 4;
    GESTURE     :: 5;
    SWITCH      :: 6;

    LIBINPUT_DEVICE_CAP_KEYBOARD    :: KEYBOARD;
    LIBINPUT_DEVICE_CAP_POINTER     :: POINTER;
    LIBINPUT_DEVICE_CAP_TOUCH       :: TOUCH;
    LIBINPUT_DEVICE_CAP_TABLET_TOOL :: TABLET_TOOL;
    LIBINPUT_DEVICE_CAP_TABLET_PAD  :: TABLET_PAD;
    LIBINPUT_DEVICE_CAP_GESTURE     :: GESTURE;
    LIBINPUT_DEVICE_CAP_SWITCH      :: SWITCH;
}

/**
* @ingroup device
*
* Logical state of a key. Note that the logical state may not represent
* the physical state of the key.
*/
libinput_key_state :: enum u32 {
    RELEASED :: 0;
    PRESSED  :: 1;

    LIBINPUT_KEY_STATE_RELEASED :: RELEASED;
    LIBINPUT_KEY_STATE_PRESSED  :: PRESSED;
}

/**
* @ingroup device
*
* Mask reflecting LEDs on a device.
*/
libinput_led :: enum u32 {
    NUM_LOCK    :: 1;
    CAPS_LOCK   :: 2;
    SCROLL_LOCK :: 4;
    COMPOSE     :: 8;
    KANA        :: 16;

    LIBINPUT_LED_NUM_LOCK    :: NUM_LOCK;
    LIBINPUT_LED_CAPS_LOCK   :: CAPS_LOCK;
    LIBINPUT_LED_SCROLL_LOCK :: SCROLL_LOCK;
    LIBINPUT_LED_COMPOSE     :: COMPOSE;
    LIBINPUT_LED_KANA        :: KANA;
}

/**
* @ingroup device
*
* Logical state of a physical button. Note that the logical state may not
* represent the physical state of the button.
*/
libinput_button_state :: enum u32 {
    RELEASED :: 0;
    PRESSED  :: 1;

    LIBINPUT_BUTTON_STATE_RELEASED :: RELEASED;
    LIBINPUT_BUTTON_STATE_PRESSED  :: PRESSED;
}

/**
* @ingroup device
*
* Axes on a device with the capability @ref LIBINPUT_DEVICE_CAP_POINTER
* that are not x or y coordinates.
*
* The two scroll axes @ref LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL and
* @ref LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL are engaged separately,
* depending on the device. libinput provides some scroll direction locking
* but it is up to the caller to determine which axis is needed and
* appropriate in the current interaction
*/
libinput_pointer_axis :: enum u32 {
    VERTICAL   :: 0;
    HORIZONTAL :: 1;

    LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL   :: VERTICAL;
    LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL :: HORIZONTAL;
}

/**
* @ingroup device
*
* The source for a libinput_pointer_axis event. See
* libinput_event_pointer_get_axis_source() for details.
*
* @note Pointer axis sources are deprecated, the source is now encoded in
* the event types
* @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
* @ref LIBINPUT_EVENT_POINTER_SCROLL_FINGER, and
* @ref LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS.
*/
libinput_pointer_axis_source :: enum u32 {
    WHEEL      :: 1;
    FINGER     :: 2;
    CONTINUOUS :: 3;
    WHEEL_TILT :: 4;

    LIBINPUT_POINTER_AXIS_SOURCE_WHEEL      :: WHEEL;
    LIBINPUT_POINTER_AXIS_SOURCE_FINGER     :: FINGER;
    LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS :: CONTINUOUS;
    LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT :: WHEEL_TILT;
}

/**
* @ingroup event_tablet_pad
*
* The source for a @ref LIBINPUT_EVENT_TABLET_PAD_RING event. See
* libinput_event_tablet_pad_get_ring_source() for details.
*
* @since 1.3
*/
libinput_tablet_pad_ring_axis_source :: enum u32 {
    UNKNOWN :: 1;
    FINGER  :: 2;

    LIBINPUT_TABLET_PAD_RING_SOURCE_UNKNOWN :: UNKNOWN;
    LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER  :: FINGER;
}

/**
* @ingroup event_tablet_pad
*
* The source for a @ref LIBINPUT_EVENT_TABLET_PAD_STRIP event. See
* libinput_event_tablet_pad_get_strip_source() for details.
*
* @since 1.3
*/
libinput_tablet_pad_strip_axis_source :: enum u32 {
    UNKNOWN :: 1;
    FINGER  :: 2;

    LIBINPUT_TABLET_PAD_STRIP_SOURCE_UNKNOWN :: UNKNOWN;
    LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER  :: FINGER;
}

/**
* @ingroup device
*
* Available tool types for a device with the @ref
* LIBINPUT_DEVICE_CAP_TABLET_TOOL capability. The tool type defines the default
* usage of the tool as advertised by the manufacturer. Multiple different
* physical tools may share the same tool type, e.g. a Wacom Classic Pen,
* Wacom Pro Pen and a Wacom Grip Pen are all of type @ref
* LIBINPUT_TABLET_TOOL_TYPE_PEN.
* Use libinput_tablet_tool_get_tool_id() to get a specific model where applicable.
*
* Note that on some device, the eraser tool is on the tail end of a pen
* device. On other devices, e.g. MS Surface 3, the eraser is the pen tip
* while a button is held down.
*
* @note The @ref libinput_tablet_tool_type can only describe the default physical
* type of the device. For devices with adjustable physical properties
* the tool type remains the same, i.e. putting a Wacom stroke nib into a
* classic pen leaves the tool type as @ref LIBINPUT_TABLET_TOOL_TYPE_PEN.
*
* @since 1.2
*/
libinput_tablet_tool_type :: enum u32 {
    PEN      :: 1;
    ERASER   :: 2;
    BRUSH    :: 3;
    PENCIL   :: 4;
    AIRBRUSH :: 5;
    MOUSE    :: 6;
    LENS     :: 7;
    TOTEM    :: 8;

    LIBINPUT_TABLET_TOOL_TYPE_PEN      :: PEN;
    LIBINPUT_TABLET_TOOL_TYPE_ERASER   :: ERASER;
    LIBINPUT_TABLET_TOOL_TYPE_BRUSH    :: BRUSH;
    LIBINPUT_TABLET_TOOL_TYPE_PENCIL   :: PENCIL;
    LIBINPUT_TABLET_TOOL_TYPE_AIRBRUSH :: AIRBRUSH;
    LIBINPUT_TABLET_TOOL_TYPE_MOUSE    :: MOUSE;
    LIBINPUT_TABLET_TOOL_TYPE_LENS     :: LENS;
    LIBINPUT_TABLET_TOOL_TYPE_TOTEM    :: TOTEM;
}

/**
* @ingroup device
*
* The state of proximity for a tool on a device. The device must have the @ref
* LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
*
* The proximity of a tool is a binary state signalling whether the tool is
* within a detectable distance of the tablet device. A tool that is out of
* proximity cannot generate events.
*
* On some hardware a tool goes out of proximity when it ceases to touch the
* surface. On other hardware, the tool is still detectable within a short
* distance (a few cm) off the surface.
*
* @since 1.2
*/
libinput_tablet_tool_proximity_state :: enum u32 {
    OUT :: 0;
    IN  :: 1;

    LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_OUT :: OUT;
    LIBINPUT_TABLET_TOOL_PROXIMITY_STATE_IN  :: IN;
}

/**
* @ingroup device
*
* The tip contact state for a tool on a device. The device must have
* the @ref LIBINPUT_DEVICE_CAP_TABLET_TOOL capability.
*
* The tip contact state of a tool is a binary state signalling whether the tool is
* touching the surface of the tablet device.
*
* @since 1.2
*/
libinput_tablet_tool_tip_state :: enum u32 {
    UP   :: 0;
    DOWN :: 1;

    LIBINPUT_TABLET_TOOL_TIP_UP   :: UP;
    LIBINPUT_TABLET_TOOL_TIP_DOWN :: DOWN;
}

/**
* @ingroup tablet_pad_modes
* @struct libinput_tablet_pad_mode_group
*
* A mode on a tablet pad is a virtual grouping of functionality, usually
* based on some visual feedback like LEDs on the pad. The set of buttons,
* rings and strips that share the same mode are a "mode group". Whenever
* the mode changes, all buttons, rings and strips within this mode group
* are affected.
*
* Most tablets only have a single mode group, some tablets provide multiple
* mode groups through independent banks of LEDs (e.g. the Wacom Cintiq
* 24HD). libinput guarantees that at least one mode group is always
* available.
*
* This struct is refcounted, use libinput_tablet_pad_mode_group_ref() and
* libinput_tablet_pad_mode_group_unref().
*
* @since 1.4
*/
libinput_tablet_pad_mode_group :: struct {}

/**
* @ingroup tablet_pad_modes
*
* Most devices only provide a single mode group, however devices such as
* the Wacom Cintiq 22HD provide two mode groups. If multiple mode groups
* are available, a caller should use
* libinput_tablet_pad_mode_group_has_button(),
* libinput_tablet_pad_mode_group_has_ring(),
* libinput_tablet_pad_mode_group_has_dial() and
* libinput_tablet_pad_mode_group_has_strip() to associate each button,
* ring and strip with the correct mode group.
*
* @return the number of mode groups available on this device
*
* @since 1.4
*/
libinput_device_tablet_pad_get_num_mode_groups :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* The returned mode group is not refcounted and may become invalid after
* the next call to libinput. Use libinput_tablet_pad_mode_group_ref() and
* libinput_tablet_pad_mode_group_unref() to continue using the handle
* outside of the immediate scope.
*
* While at least one reference is kept by the caller, the returned mode
* group will be identical for each subsequent call of this function with
* the same index and that same struct is returned from
* libinput_event_tablet_pad_get_mode_group(), provided the event was
* generated by this mode group.
*
* @param device A device with the @ref LIBINPUT_DEVICE_CAP_TABLET_PAD
* capability
* @param index A mode group index
* @return the mode group with the given index or NULL if an invalid index
* is given.
*
* @since 1.4
*/
libinput_device_tablet_pad_get_mode_group :: (device: *libinput_device, index: u32) -> *libinput_tablet_pad_mode_group #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* The returned number is the same index as passed to
* libinput_device_tablet_pad_get_mode_group(). For tablets with only one
* mode this number is always 0.
*
* @param group A previously obtained mode group
* @return the numeric index this mode group represents, starting at 0
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_get_index :: (group: *libinput_tablet_pad_mode_group) -> u32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Query the mode group for the number of available modes. The number of
* modes is usually decided by the number of physical LEDs available on the
* device. Different mode groups may have a different number of modes. Use
* libinput_tablet_pad_mode_group_get_mode() to get the currently active
* mode.
*
* libinput guarantees that at least one mode is available. A device without
* mode switching capability has a single mode group and a single mode.
*
* @param group A previously obtained mode group
* @return the number of modes available in this mode group
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_get_num_modes :: (group: *libinput_tablet_pad_mode_group) -> u32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Return the current mode this mode group is in. Note that the returned
* mode is the mode valid as of completing the last libinput_dispatch().
* The returned mode may thus be different than the mode returned by
* libinput_event_tablet_pad_get_mode().
*
* For example, if the mode was toggled three times between the call to
* libinput_dispatch(), this function returns the third mode but the events
* in the event queue will return the modes 1, 2 and 3, respectively.
*
* @param group A previously obtained mode group
* @return the numeric index of the current mode in this group, starting at 0
*
* @see libinput_event_tablet_pad_get_mode
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_get_mode :: (group: *libinput_tablet_pad_mode_group) -> u32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Devices without mode switching capabilities return true for every button.
*
* @param group A previously obtained mode group
* @param button A button index, starting at 0
* @return true if the given button index is part of this mode group or
* false otherwise
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_has_button :: (group: *libinput_tablet_pad_mode_group, button: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Devices without mode switching capabilities return true for every dial.
*
* @param group A previously obtained mode group
* @param dial A dial index, starting at 0
* @return true if the given dial index is part of this mode group or
* false otherwise
*
* @since 1.26
*/
libinput_tablet_pad_mode_group_has_dial :: (group: *libinput_tablet_pad_mode_group, dial: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Devices without mode switching capabilities return true for every ring.
*
* @param group A previously obtained mode group
* @param ring A ring index, starting at 0
* @return true if the given ring index is part of this mode group or
* false otherwise
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_has_ring :: (group: *libinput_tablet_pad_mode_group, ring: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Devices without mode switching capabilities return true for every strip.
*
* @param group A previously obtained mode group
* @param strip A strip index, starting at 0
* @return true if the given strip index is part of this mode group or
* false otherwise
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_has_strip :: (group: *libinput_tablet_pad_mode_group, strip: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* The toggle button in a mode group is the button assigned to cycle to or
* directly assign a new mode when pressed. Not all devices have a toggle
* button and some devices may have more than one toggle button. For
* example, the Wacom Cintiq 24HD has six toggle buttons in two groups, each
* directly selecting one of the three modes per group.
*
* Devices without mode switching capabilities return false for every button.
*
* @param group A previously obtained mode group
* @param button A button index, starting at 0
* @retval non-zero if the button is a mode toggle button for this group, or
* zero otherwise
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_button_is_toggle :: (group: *libinput_tablet_pad_mode_group, button: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Increase the refcount of the mode group. A mode group will be
* freed whenever the refcount reaches 0.
*
* @param group A previously obtained mode group
* @return The passed mode group
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_ref :: (group: *libinput_tablet_pad_mode_group) -> *libinput_tablet_pad_mode_group #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Decrease the refcount of the mode group. A mode group will be
* freed whenever the refcount reaches 0.
*
* @param group A previously obtained mode group
* @return NULL if the group was destroyed, otherwise the passed mode group
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_unref :: (group: *libinput_tablet_pad_mode_group) -> *libinput_tablet_pad_mode_group #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Set caller-specific data associated with this mode group. libinput does
* not manage, look at, or modify this data. The caller must ensure the
* data is valid.
*
* @param group A previously obtained mode group
* @param user_data Caller-specific data pointer
* @see libinput_tablet_pad_mode_group_get_user_data
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_set_user_data :: (group: *libinput_tablet_pad_mode_group, user_data: *void) -> void #foreign libinput_lib;

/**
* @ingroup tablet_pad_modes
*
* Get the caller-specific data associated with this mode group, if any.
*
* @param group A previously obtained mode group
* @return Caller-specific data pointer or NULL if none was set
* @see libinput_tablet_pad_mode_group_set_user_data
*
* @since 1.4
*/
libinput_tablet_pad_mode_group_get_user_data :: (group: *libinput_tablet_pad_mode_group) -> *void #foreign libinput_lib;

/**
* @ingroup device
*
* The state of a switch. The default state of a switch is @ref
* LIBINPUT_SWITCH_STATE_OFF and no event is sent to confirm a switch in the
* off position. If a switch is logically on during initialization, libinput
* sends an event of type @ref LIBINPUT_EVENT_SWITCH_TOGGLE with a state
* @ref LIBINPUT_SWITCH_STATE_ON.
*
* @since 1.7
*/
libinput_switch_state :: enum u32 {
    OFF :: 0;
    ON  :: 1;

    LIBINPUT_SWITCH_STATE_OFF :: OFF;
    LIBINPUT_SWITCH_STATE_ON  :: ON;
}

/**
* @ingroup device
*
* The type of a switch.
*
* @since 1.7
*/
libinput_switch :: enum u32 {
    LID         :: 1;
    TABLET_MODE :: 2;

    LIBINPUT_SWITCH_LID         :: LID;
    LIBINPUT_SWITCH_TABLET_MODE :: TABLET_MODE;
}

/**
* @ingroup event_switch
* @struct libinput_event_switch
*
* A switch event representing a changed state in a switch.
*
* @since 1.7
*/
libinput_event_switch :: struct {}

/**
* @ingroup base
*
* Event type for events returned by libinput_get_event().
*/
libinput_event_type :: enum u32 {
    NONE                      :: 0;
    DEVICE_ADDED              :: 1;
    DEVICE_REMOVED            :: 2;
    KEYBOARD_KEY              :: 300;
    POINTER_MOTION            :: 400;
    POINTER_MOTION_ABSOLUTE   :: 401;
    POINTER_BUTTON            :: 402;
    POINTER_AXIS              :: 403;
    POINTER_SCROLL_WHEEL      :: 404;
    POINTER_SCROLL_FINGER     :: 405;
    POINTER_SCROLL_CONTINUOUS :: 406;
    TOUCH_DOWN                :: 500;
    TOUCH_UP                  :: 501;
    TOUCH_MOTION              :: 502;
    TOUCH_CANCEL              :: 503;
    TOUCH_FRAME               :: 504;
    TABLET_TOOL_AXIS          :: 600;
    TABLET_TOOL_PROXIMITY     :: 601;
    TABLET_TOOL_TIP           :: 602;
    TABLET_TOOL_BUTTON        :: 603;
    TABLET_PAD_BUTTON         :: 700;
    TABLET_PAD_RING           :: 701;
    TABLET_PAD_STRIP          :: 702;
    TABLET_PAD_KEY            :: 703;
    TABLET_PAD_DIAL           :: 704;
    GESTURE_SWIPE_BEGIN       :: 800;
    GESTURE_SWIPE_UPDATE      :: 801;
    GESTURE_SWIPE_END         :: 802;
    GESTURE_PINCH_BEGIN       :: 803;
    GESTURE_PINCH_UPDATE      :: 804;
    GESTURE_PINCH_END         :: 805;
    GESTURE_HOLD_BEGIN        :: 806;
    GESTURE_HOLD_END          :: 807;
    SWITCH_TOGGLE             :: 900;

    LIBINPUT_EVENT_NONE                      :: NONE;
    LIBINPUT_EVENT_DEVICE_ADDED              :: DEVICE_ADDED;
    LIBINPUT_EVENT_DEVICE_REMOVED            :: DEVICE_REMOVED;
    LIBINPUT_EVENT_KEYBOARD_KEY              :: KEYBOARD_KEY;
    LIBINPUT_EVENT_POINTER_MOTION            :: POINTER_MOTION;
    LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE   :: POINTER_MOTION_ABSOLUTE;
    LIBINPUT_EVENT_POINTER_BUTTON            :: POINTER_BUTTON;
    LIBINPUT_EVENT_POINTER_AXIS              :: POINTER_AXIS;
    LIBINPUT_EVENT_POINTER_SCROLL_WHEEL      :: POINTER_SCROLL_WHEEL;
    LIBINPUT_EVENT_POINTER_SCROLL_FINGER     :: POINTER_SCROLL_FINGER;
    LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS :: POINTER_SCROLL_CONTINUOUS;
    LIBINPUT_EVENT_TOUCH_DOWN                :: TOUCH_DOWN;
    LIBINPUT_EVENT_TOUCH_UP                  :: TOUCH_UP;
    LIBINPUT_EVENT_TOUCH_MOTION              :: TOUCH_MOTION;
    LIBINPUT_EVENT_TOUCH_CANCEL              :: TOUCH_CANCEL;
    LIBINPUT_EVENT_TOUCH_FRAME               :: TOUCH_FRAME;
    LIBINPUT_EVENT_TABLET_TOOL_AXIS          :: TABLET_TOOL_AXIS;
    LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY     :: TABLET_TOOL_PROXIMITY;
    LIBINPUT_EVENT_TABLET_TOOL_TIP           :: TABLET_TOOL_TIP;
    LIBINPUT_EVENT_TABLET_TOOL_BUTTON        :: TABLET_TOOL_BUTTON;
    LIBINPUT_EVENT_TABLET_PAD_BUTTON         :: TABLET_PAD_BUTTON;
    LIBINPUT_EVENT_TABLET_PAD_RING           :: TABLET_PAD_RING;
    LIBINPUT_EVENT_TABLET_PAD_STRIP          :: TABLET_PAD_STRIP;
    LIBINPUT_EVENT_TABLET_PAD_KEY            :: TABLET_PAD_KEY;
    LIBINPUT_EVENT_TABLET_PAD_DIAL           :: TABLET_PAD_DIAL;
    LIBINPUT_EVENT_GESTURE_SWIPE_BEGIN       :: GESTURE_SWIPE_BEGIN;
    LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE      :: GESTURE_SWIPE_UPDATE;
    LIBINPUT_EVENT_GESTURE_SWIPE_END         :: GESTURE_SWIPE_END;
    LIBINPUT_EVENT_GESTURE_PINCH_BEGIN       :: GESTURE_PINCH_BEGIN;
    LIBINPUT_EVENT_GESTURE_PINCH_UPDATE      :: GESTURE_PINCH_UPDATE;
    LIBINPUT_EVENT_GESTURE_PINCH_END         :: GESTURE_PINCH_END;
    LIBINPUT_EVENT_GESTURE_HOLD_BEGIN        :: GESTURE_HOLD_BEGIN;
    LIBINPUT_EVENT_GESTURE_HOLD_END          :: GESTURE_HOLD_END;
    LIBINPUT_EVENT_SWITCH_TOGGLE             :: SWITCH_TOGGLE;
}

/**
* @ingroup event
*
* Destroy the event, freeing all associated resources. Resources obtained
* from this event must be considered invalid after this call.
*
* @warning Unlike other structs events are considered transient and
* <b>not</b> refcounted. Calling libinput_event_destroy() <b>will</b>
* destroy the event.
*
* @param event An event retrieved by libinput_get_event().
*/
libinput_event_destroy :: (event: *libinput_event) -> void #foreign libinput_lib;

/**
* @ingroup event
*
* Get the type of the event.
*
* @param event An event retrieved by libinput_get_event().
*/
libinput_event_get_type :: (event: *libinput_event) -> libinput_event_type #foreign libinput_lib;

/**
* @ingroup event
*
* Get the libinput context from the event.
*
* @param event The libinput event
* @return The libinput context for this event.
*/
libinput_event_get_context :: (event: *libinput_event) -> *libinput #foreign libinput_lib;

/**
* @ingroup event
*
* Return the device associated with this event. For device added/removed
* events this is the device added or removed. For all other device events,
* this is the device that generated the event.
*
* This device is not refcounted and its lifetime is that of the event. Use
* libinput_device_ref() before using the device outside of this scope.
*
* @return The device associated with this event
*/
libinput_event_get_device :: (event: *libinput_event) -> *libinput_device #foreign libinput_lib;

/**
* @ingroup event
*
* Return the pointer event that is this input event. If the event type does
* not match the pointer event types, this function returns NULL.
*
* The inverse of this function is libinput_event_pointer_get_base_event().
*
* @return A pointer event, or NULL for other events
*/
libinput_event_get_pointer_event :: (event: *libinput_event) -> *libinput_event_pointer #foreign libinput_lib;

/**
* @ingroup event
*
* Return the keyboard event that is this input event. If the event type does
* not match the keyboard event types, this function returns NULL.
*
* The inverse of this function is libinput_event_keyboard_get_base_event().
*
* @return A keyboard event, or NULL for other events
*/
libinput_event_get_keyboard_event :: (event: *libinput_event) -> *libinput_event_keyboard #foreign libinput_lib;

/**
* @ingroup event
*
* Return the touch event that is this input event. If the event type does
* not match the touch event types, this function returns NULL.
*
* The inverse of this function is libinput_event_touch_get_base_event().
*
* @return A touch event, or NULL for other events
*/
libinput_event_get_touch_event :: (event: *libinput_event) -> *libinput_event_touch #foreign libinput_lib;

libinput_event_gesture :: struct {}
/**
* @ingroup event
*
* Return the gesture event that is this input event. If the event type does
* not match the gesture event types, this function returns NULL.
*
* A gesture's lifetime has three distinct stages: begin, update and end, each
* with their own event types. Begin is sent when the fingers are first set
* down or libinput decides that the gesture begins. For @ref
* LIBINPUT_EVENT_GESTURE_PINCH_BEGIN this sets the initial scale. Any
* events changing properties of the gesture are sent as update events. On
* termination of the gesture, an end event is sent.
*
* The inverse of this function is libinput_event_gesture_get_base_event().
*
* @return A gesture event, or NULL for other events
*/
libinput_event_get_gesture_event :: (event: *libinput_event) -> *libinput_event_gesture #foreign libinput_lib;

/**
* @ingroup event
*
* Return the tablet tool event that is this input event. If the event type
* does not match the tablet tool event types, this function returns NULL.
*
* The inverse of this function is libinput_event_tablet_tool_get_base_event().
*
* @return A tablet tool event, or NULL for other events
*
* @since 1.2
*/
libinput_event_get_tablet_tool_event :: (event: *libinput_event) -> *libinput_event_tablet_tool #foreign libinput_lib;

/**
* @ingroup event
*
* Return the tablet pad event that is this input event. If the event type does not
* match the tablet pad event types, this function returns NULL.
*
* The inverse of this function is libinput_event_tablet_pad_get_base_event().
*
* @return A tablet pad event, or NULL for other events
*/
libinput_event_get_tablet_pad_event :: (event: *libinput_event) -> *libinput_event_tablet_pad #foreign libinput_lib;

/**
* @ingroup event
*
* Return the switch event that is this input event. If the event type does
* not match the switch event types, this function returns NULL.
*
* The inverse of this function is libinput_event_switch_get_base_event().
*
* @return A switch event, or NULL for other events
*
* @since 1.7
*/
libinput_event_get_switch_event :: (event: *libinput_event) -> *libinput_event_switch #foreign libinput_lib;

/**
* @ingroup event
*
* Return the device event that is this input event. If the event type does
* not match the device event types, this function returns NULL.
*
* The inverse of this function is
* libinput_event_device_notify_get_base_event().
*
* @return A device event, or NULL for other events
*/
libinput_event_get_device_notify_event :: (event: *libinput_event) -> *libinput_event_device_notify #foreign libinput_lib;

/**
* @ingroup event
*
* @return The generic libinput_event of this event
*/
libinput_event_device_notify_get_base_event :: (event: *libinput_event_device_notify) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_keyboard
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event
*/
libinput_event_keyboard_get_time :: (event: *libinput_event_keyboard) -> u32 #foreign libinput_lib;

/**
* @ingroup event_keyboard
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event in microseconds
*/
libinput_event_keyboard_get_time_usec :: (event: *libinput_event_keyboard) -> u64 #foreign libinput_lib;

/**
* @ingroup event_keyboard
*
* @return The keycode that triggered this key event
*/
libinput_event_keyboard_get_key :: (event: *libinput_event_keyboard) -> u32 #foreign libinput_lib;

/**
* @ingroup event_keyboard
*
* @return The state change of the key
*/
libinput_event_keyboard_get_key_state :: (event: *libinput_event_keyboard) -> libinput_key_state #foreign libinput_lib;

/**
* @ingroup event_keyboard
*
* @return The generic libinput_event of this event
*/
libinput_event_keyboard_get_base_event :: (event: *libinput_event_keyboard) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_keyboard
*
* For the key of a @ref LIBINPUT_EVENT_KEYBOARD_KEY event, return the total number
* of keys pressed on all devices on the associated seat after the event was
* triggered.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_KEYBOARD_KEY. For other events, this function returns 0.
*
* @return The seat wide pressed key count for the key of this event
*/
libinput_event_keyboard_get_seat_key_count :: (event: *libinput_event_keyboard) -> u32 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event
*/
libinput_event_pointer_get_time :: (event: *libinput_event_pointer) -> u32 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event in microseconds
*/
libinput_event_pointer_get_time_usec :: (event: *libinput_event_pointer) -> u64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the delta between the last event and the current event. For pointer
* events that are not of type @ref LIBINPUT_EVENT_POINTER_MOTION, this
* function returns 0.
*
* If a device employs pointer acceleration, the delta returned by this
* function is the accelerated delta.
*
* Relative motion deltas are to be interpreted as pixel movement of a
* standardized mouse. See the libinput documentation for more details.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION.
*
* @return The relative x movement since the last event
*/
libinput_event_pointer_get_dx :: (event: *libinput_event_pointer) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the delta between the last event and the current event. For pointer
* events that are not of type @ref LIBINPUT_EVENT_POINTER_MOTION, this
* function returns 0.
*
* If a device employs pointer acceleration, the delta returned by this
* function is the accelerated delta.
*
* Relative motion deltas are to be interpreted as pixel movement of a
* standardized mouse. See the libinput documentation for more details.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION.
*
* @return The relative y movement since the last event
*/
libinput_event_pointer_get_dy :: (event: *libinput_event_pointer) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the relative delta of the unaccelerated motion vector of the
* current event. For pointer events that are not of type @ref
* LIBINPUT_EVENT_POINTER_MOTION, this function returns 0.
*
* Relative unaccelerated motion deltas are raw device coordinates.
* Note that these coordinates are subject to the device's native
* resolution. Touchpad coordinates represent raw device coordinates in the
* X resolution of the touchpad. See the libinput documentation for more
* details.
*
* Any rotation applied to the device also applies to unaccelerated motion
* (see libinput_device_config_rotation_set_angle()).
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION.
*
* @return The unaccelerated relative x movement since the last event
*/
libinput_event_pointer_get_dx_unaccelerated :: (event: *libinput_event_pointer) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the relative delta of the unaccelerated motion vector of the
* current event. For pointer events that are not of type @ref
* LIBINPUT_EVENT_POINTER_MOTION, this function returns 0.
*
* Relative unaccelerated motion deltas are raw device coordinates.
* Note that these coordinates are subject to the device's native
* resolution. Touchpad coordinates represent raw device coordinates in the
* X resolution of the touchpad. See the libinput documentation for more
* details.
*
* Any rotation applied to the device also applies to unaccelerated motion
* (see libinput_device_config_rotation_set_angle()).
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION.
*
* @return The unaccelerated relative y movement since the last event
*/
libinput_event_pointer_get_dy_unaccelerated :: (event: *libinput_event_pointer) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the current absolute x coordinate of the pointer event, in mm from
* the top left corner of the device. To get the corresponding output screen
* coordinate, use libinput_event_pointer_get_absolute_x_transformed().
*
* For pointer events that are not of type
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
*
* @return The current absolute x coordinate
*/
libinput_event_pointer_get_absolute_x :: (event: *libinput_event_pointer) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the current absolute y coordinate of the pointer event, in mm from
* the top left corner of the device. To get the corresponding output screen
* coordinate, use libinput_event_pointer_get_absolute_y_transformed().
*
* For pointer events that are not of type
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
*
* @return The current absolute y coordinate
*/
libinput_event_pointer_get_absolute_y :: (event: *libinput_event_pointer) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the current absolute x coordinate of the pointer event, transformed to
* screen coordinates.
*
* For pointer events that are not of type
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, the return value of this
* function is undefined.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
*
* @param event The libinput pointer event
* @param width The current output screen width
* @return The current absolute x coordinate transformed to a screen coordinate
*/
libinput_event_pointer_get_absolute_x_transformed :: (event: *libinput_event_pointer, width: u32) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the current absolute y coordinate of the pointer event, transformed to
* screen coordinates.
*
* For pointer events that are not of type
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE, the return value of this function is
* undefined.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_MOTION_ABSOLUTE.
*
* @param event The libinput pointer event
* @param height The current output screen height
* @return The current absolute y coordinate transformed to a screen coordinate
*/
libinput_event_pointer_get_absolute_y_transformed :: (event: *libinput_event_pointer, height: u32) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the button that triggered this event.
* For pointer events that are not of type @ref
* LIBINPUT_EVENT_POINTER_BUTTON, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_BUTTON.
*
* @return The button triggering this event
*/
libinput_event_pointer_get_button :: (event: *libinput_event_pointer) -> u32 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the button state that triggered this event.
* For pointer events that are not of type @ref
* LIBINPUT_EVENT_POINTER_BUTTON, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_BUTTON.
*
* @return The button state triggering this event
*/
libinput_event_pointer_get_button_state :: (event: *libinput_event_pointer) -> libinput_button_state #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* For the button of a @ref LIBINPUT_EVENT_POINTER_BUTTON event, return the
* total number of buttons pressed on all devices on the associated seat
* after the event was triggered.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_BUTTON. For other events, this function
* returns 0.
*
* @return The seat wide pressed button count for the key of this event
*/
libinput_event_pointer_get_seat_button_count :: (event: *libinput_event_pointer) -> u32 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Check if the event has a valid value for the given axis.
*
* If this function returns non-zero for an axis and
* libinput_event_pointer_get_axis_value() returns a value of 0, the event
* is a scroll stop event.
*
* For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
* @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL, @ref
* LIBINPUT_EVENT_POINTER_SCROLL_FINGER, or @ref
* LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_AXIS,
* @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
* @ref LIBINPUT_EVENT_POINTER_SCROLL_FINGER, or
* @ref LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS.
*
* @return Non-zero if this event contains a value for this axis
*/
libinput_event_pointer_has_axis :: (event: *libinput_event_pointer, axis: libinput_pointer_axis) -> s32 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the axis value of the given axis. The interpretation of the value
* depends on the axis. For the two scrolling axes
* @ref LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL and
* @ref LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL, the value of the event is in
* relative scroll units, with the positive direction being down or right,
* respectively. For the interpretation of the value, see
* libinput_event_pointer_get_axis_source().
*
* If libinput_event_pointer_has_axis() returns 0 for an axis, this function
* returns 0 for that axis.
*
* For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
* this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_AXIS.
*
* @return The axis value of this event
*
* @see libinput_event_pointer_get_axis_value_discrete
*/
libinput_event_pointer_get_axis_value :: (event: *libinput_event_pointer, axis: libinput_pointer_axis) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the source for a given axis event. Axis events (scroll events) can
* be caused by a hardware item such as a scroll wheel or emulated from
* other input sources, such as two-finger or edge scrolling on a
* touchpad.
*
* If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_FINGER, libinput
* guarantees that a scroll sequence is terminated with a scroll value of 0.
* A caller may use this information to decide on whether kinetic scrolling
* should be triggered on this scroll sequence.
* The coordinate system is identical to the cursor movement, i.e. a
* scroll value of 1 represents the equivalent relative motion of 1.
*
* If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL, no terminating
* event is guaranteed (though it may happen).
* Scrolling is in discrete steps, the value is the angle the wheel moved
* in degrees. The default is 15 degrees per wheel click, but some mice may
* have differently grained wheels. It is up to the caller how to interpret
* such different step sizes. Callers should use
* libinput_event_pointer_get_scroll_value_v120() for a simpler API of
* handling scroll wheel events of different step sizes.
*
* If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS, libinput
* guarantees that a scroll sequence is terminated with a scroll value of 0.
* The coordinate system is identical to the cursor movement, i.e. a
* scroll value of 1 represents the equivalent relative motion of 1.
*
* @deprecated The source @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL_TILT is
* deprecated as of libinput 1.16. No device has ever sent this source.
*
* For pointer events that are not of type @ref LIBINPUT_EVENT_POINTER_AXIS,
* this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_AXIS.
*
* @note This function is superfluous as of libinput 1.19. The event
* codes for @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL, @ref
* LIBINPUT_EVENT_POINTER_SCROLL_FINGER and @ref
* LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS have the axis source encoded in
* the event type.
*
* @return The source for this axis event
*/
libinput_event_pointer_get_axis_source :: (event: *libinput_event_pointer) -> libinput_pointer_axis_source #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the axis value in discrete steps for a given axis event. How a
* value translates into a discrete step depends on the source.
*
* @note This function does not support high-resolution mouse wheels and
* should be considered deprecated as of libinput 1.19. Callers should use
* @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL and
* libinput_event_pointer_get_scroll_value_v120() instead.
*
* If the event is not of type @ref LIBINPUT_EVENT_POINTER_AXIS, this
* function returns 0.
*
* If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_WHEEL, the discrete
* value correspond to the number of physical mouse wheel clicks.
*
* If the source is @ref LIBINPUT_POINTER_AXIS_SOURCE_CONTINUOUS or @ref
* LIBINPUT_POINTER_AXIS_SOURCE_FINGER, the discrete value is always 0.
*
* @return The discrete value for the given event.
*
* @see libinput_event_pointer_get_axis_value
* @see libinput_event_pointer_get_scroll_value_v120
*/
libinput_event_pointer_get_axis_value_discrete :: (event: *libinput_event_pointer, axis: libinput_pointer_axis) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* Return the axis value of the given axis. The interpretation of the value
* depends on the axis. For the two scrolling axes
* @ref LIBINPUT_POINTER_AXIS_SCROLL_VERTICAL and
* @ref LIBINPUT_POINTER_AXIS_SCROLL_HORIZONTAL, the value of the event is in
* relative scroll units, with the positive direction being down or right,
* respectively. If libinput_event_pointer_has_axis() returns 0 for an axis,
* this function returns 0 for that axis.
*
* If the event is @ref LIBINPUT_EVENT_POINTER_SCROLL_FINGER, libinput
* guarantees that a scroll sequence is terminated with a scroll value of 0.
* A caller may use this information to decide on whether kinetic scrolling
* should be triggered on this scroll sequence.
* The coordinate system is identical to the cursor movement, i.e. a
* scroll value of 1 represents the equivalent relative motion of 1.
*
* If the event is @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL, no terminating
* event is guaranteed (though it may happen).
* Scrolling is in discrete steps, the value is the angle the wheel moved
* in degrees. The default is 15 degrees per wheel click, but some mice may
* have differently grained wheels. It is up to the caller how to interpret
* such different step sizes. Callers should use
* libinput_event_pointer_get_scroll_value_v120() for a simpler API of
* handling scroll wheel events of different step sizes.
*
* If the event is @ref LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS, libinput
* guarantees that a scroll sequence is terminated with a scroll value of 0.
* The coordinate system is identical to the cursor movement, i.e. a
* scroll value of 1 represents the equivalent relative motion of 1.
*
* For pointer events that are not of type
* @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
* @ref LIBINPUT_EVENT_POINTER_SCROLL_FINGER, or
* @ref LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS, this function returns zero.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL,
* @ref LIBINPUT_EVENT_POINTER_SCROLL_FINGER, or
* @ref LIBINPUT_EVENT_POINTER_SCROLL_CONTINUOUS.
*
* @return The axis value of this event
*
* @see libinput_event_pointer_get_scroll_value_v120
*
* @since 1.19
*/
libinput_event_pointer_get_scroll_value :: (event: *libinput_event_pointer, axis: libinput_pointer_axis) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* For events of type @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL
* the v120-normalized value represents the movement in logical mouse wheel
* clicks, normalized to the -120..+120 range.
*
* A value that is a fraction of ±120 indicates a wheel movement less than
* one logical click, a caller should either scroll by the respective
* fraction of the normal scroll distance or accumulate that value until a
* multiple of 120 is reached.
*
* For most callers, this is the preferred way of handling high-resolution
* scroll events.
*
* The normalized v120 value does not take device-specific physical angles
* or distances into account, i.e. a wheel with a click angle of 20 degrees
* produces only 18 logical clicks per 360 degree rotation, a wheel with a
* click angle of 15 degrees produces 24 logical clicks per 360 degree
* rotation. Where the physical angle matters, use
* libinput_event_pointer_get_axis_value() instead.
*
* The magic number 120 originates from the <a
* href="http://download.microsoft.com/download/b/d/1/bd1f7ef4-7d72-419e-bc5c-9f79ad7bb66e/wheel.docx">
* Windows Vista Mouse Wheel design document</a>.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_POINTER_SCROLL_WHEEL.
*
* @return A value normalized to the 0-±120 range
*
* @see libinput_event_pointer_get_axis_value
* @see libinput_event_pointer_get_axis_value_discrete
*
* @since 1.19
*/
libinput_event_pointer_get_scroll_value_v120 :: (event: *libinput_event_pointer, axis: libinput_pointer_axis) -> float64 #foreign libinput_lib;

/**
* @ingroup event_pointer
*
* @return The generic libinput_event of this event
*/
libinput_event_pointer_get_base_event :: (event: *libinput_event_pointer) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_touch
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event
*/
libinput_event_touch_get_time :: (event: *libinput_event_touch) -> u32 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event in microseconds
*/
libinput_event_touch_get_time_usec :: (event: *libinput_event_touch) -> u64 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* Get the slot of this touch event. See the kernel's multitouch
* protocol B documentation for more information.
*
* If the touch event has no assigned slot, for example if it is from a
* single touch device, this function returns -1.
*
* For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
* LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref
* LIBINPUT_EVENT_TOUCH_CANCEL, this function returns 0.
*
* @note It is an application bug to call this function for events of type
* other than @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_UP,
* @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref LIBINPUT_EVENT_TOUCH_CANCEL.
*
* @return The slot of this touch event
*/
libinput_event_touch_get_slot :: (event: *libinput_event_touch) -> s32 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* Get the seat slot of the touch event. A seat slot is a non-negative seat
* wide unique identifier of an active touch point.
*
* Events from single touch devices will be represented as one individual
* touch point per device.
*
* For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
* LIBINPUT_EVENT_TOUCH_UP, @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref
* LIBINPUT_EVENT_TOUCH_CANCEL, this function returns 0.
*
* @note It is an application bug to call this function for events of type
* other than @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref LIBINPUT_EVENT_TOUCH_UP,
* @ref LIBINPUT_EVENT_TOUCH_MOTION or @ref LIBINPUT_EVENT_TOUCH_CANCEL.
*
* @return The seat slot of the touch event
*/
libinput_event_touch_get_seat_slot :: (event: *libinput_event_touch) -> s32 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* Return the current absolute x coordinate of the touch event, in mm from
* the top left corner of the device. To get the corresponding output screen
* coordinate, use libinput_event_touch_get_x_transformed().
*
* For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
* LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
*
* @note It is an application bug to call this function for events of type
* other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
* LIBINPUT_EVENT_TOUCH_MOTION.
*
* @param event The libinput touch event
* @return The current absolute x coordinate
*/
libinput_event_touch_get_x :: (event: *libinput_event_touch) -> float64 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* Return the current absolute y coordinate of the touch event, in mm from
* the top left corner of the device. To get the corresponding output screen
* coordinate, use libinput_event_touch_get_y_transformed().
*
* For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
* LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
*
* @note It is an application bug to call this function for events of type
* other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
* LIBINPUT_EVENT_TOUCH_MOTION.
*
* @param event The libinput touch event
* @return The current absolute y coordinate
*/
libinput_event_touch_get_y :: (event: *libinput_event_touch) -> float64 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* Return the current absolute x coordinate of the touch event, transformed to
* screen coordinates.
*
* For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
* LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
*
* @note It is an application bug to call this function for events of type
* other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
* LIBINPUT_EVENT_TOUCH_MOTION.
*
* @param event The libinput touch event
* @param width The current output screen width
* @return The current absolute x coordinate transformed to a screen coordinate
*/
libinput_event_touch_get_x_transformed :: (event: *libinput_event_touch, width: u32) -> float64 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* Return the current absolute y coordinate of the touch event, transformed to
* screen coordinates.
*
* For events not of type @ref LIBINPUT_EVENT_TOUCH_DOWN, @ref
* LIBINPUT_EVENT_TOUCH_MOTION, this function returns 0.
*
* @note It is an application bug to call this function for events of type
* other than @ref LIBINPUT_EVENT_TOUCH_DOWN or @ref
* LIBINPUT_EVENT_TOUCH_MOTION.
*
* @param event The libinput touch event
* @param height The current output screen height
* @return The current absolute y coordinate transformed to a screen coordinate
*/
libinput_event_touch_get_y_transformed :: (event: *libinput_event_touch, height: u32) -> float64 #foreign libinput_lib;

/**
* @ingroup event_touch
*
* @return The generic libinput_event of this event
*/
libinput_event_touch_get_base_event :: (event: *libinput_event_touch) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event
*/
libinput_event_gesture_get_time :: (event: *libinput_event_gesture) -> u32 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @return The event time for this event in microseconds
*/
libinput_event_gesture_get_time_usec :: (event: *libinput_event_gesture) -> u64 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* @return The generic libinput_event of this event
*/
libinput_event_gesture_get_base_event :: (event: *libinput_event_gesture) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return the number of fingers used for a gesture. This can be used e.g.
* to differentiate between 3 or 4 finger swipes.
*
* This function can be called on all gesture events and the returned finger
* count value remains the same for the lifetime of a gesture. Thus, if a
* user puts down a fourth finger during a three-finger swipe gesture,
* libinput will end the three-finger gesture and, if applicable, start a
* four-finger swipe gesture. A caller may decide that those gestures are
* semantically identical and continue the two gestures as one single gesture.
*
* @return the number of fingers used for a gesture
*/
libinput_event_gesture_get_finger_count :: (event: *libinput_event_gesture) -> s32 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return if the gesture ended normally, or if it was cancelled.
* For gesture events that are not of type
* @ref LIBINPUT_EVENT_GESTURE_SWIPE_END or
* @ref LIBINPUT_EVENT_GESTURE_PINCH_END, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_GESTURE_SWIPE_END or
* @ref LIBINPUT_EVENT_GESTURE_PINCH_END.
*
* @return 0 or 1, with 1 indicating that the gesture was cancelled.
*/
libinput_event_gesture_get_cancelled :: (event: *libinput_event_gesture) -> s32 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return the delta between the last event and the current event. For gesture
* events that are not of type @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
* @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
*
* If a device employs pointer acceleration, the delta returned by this
* function is the accelerated delta.
*
* Relative motion deltas are normalized to represent those of a device with
* 1000dpi resolution. See the libinput documentation for more details.
*
* @return the relative x movement since the last event
*/
libinput_event_gesture_get_dx :: (event: *libinput_event_gesture) -> float64 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return the delta between the last event and the current event. For gesture
* events that are not of type @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
* @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
*
* If a device employs pointer acceleration, the delta returned by this
* function is the accelerated delta.
*
* Relative motion deltas are normalized to represent those of a device with
* 1000dpi resolution. See the libinput documentation for more details.
*
* @return the relative y movement since the last event
*/
libinput_event_gesture_get_dy :: (event: *libinput_event_gesture) -> float64 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return the relative delta of the unaccelerated motion vector of the
* current event. For gesture events that are not of type
* @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
* @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
*
* Relative unaccelerated motion deltas are normalized to represent those of a
* device with 1000dpi resolution. See the libinput documentation for more
* details. Note that unaccelerated events are not equivalent to 'raw' events
* as read from the device.
*
* Any rotation applied to the device also applies to gesture motion
* (see libinput_device_config_rotation_set_angle()).
*
* @return the unaccelerated relative x movement since the last event
*/
libinput_event_gesture_get_dx_unaccelerated :: (event: *libinput_event_gesture) -> float64 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return the relative delta of the unaccelerated motion vector of the
* current event. For gesture events that are not of type
* @ref LIBINPUT_EVENT_GESTURE_SWIPE_UPDATE or
* @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this function returns 0.
*
* Relative unaccelerated motion deltas are normalized to represent those of a
* device with 1000dpi resolution. See the libinput documentation for more
* details. Note that unaccelerated events are not equivalent to 'raw' events
* as read from the device.
*
* Any rotation applied to the device also applies to gesture motion
* (see libinput_device_config_rotation_set_angle()).
*
* @return the unaccelerated relative y movement since the last event
*/
libinput_event_gesture_get_dy_unaccelerated :: (event: *libinput_event_gesture) -> float64 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return the absolute scale of a pinch gesture, the scale is the division
* of the current distance between the fingers and the distance at the start
* of the gesture. The scale begins at 1.0, and if e.g. the fingers moved
* together by 50% then the scale will become 0.5, if they move twice as far
* apart as initially the scale becomes 2.0, etc.
*
* For gesture events that are of type @ref
* LIBINPUT_EVENT_GESTURE_PINCH_BEGIN, this function returns 1.0.
*
* For gesture events that are of type @ref
* LIBINPUT_EVENT_GESTURE_PINCH_END, this function returns the scale value
* of the most recent @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE event (if
* any) or 1.0 otherwise.
*
* For all other events this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_GESTURE_PINCH_BEGIN, @ref
* LIBINPUT_EVENT_GESTURE_PINCH_END or
* @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE.
*
* @return the absolute scale of a pinch gesture
*/
libinput_event_gesture_get_scale :: (event: *libinput_event_gesture) -> float64 #foreign libinput_lib;

/**
* @ingroup event_gesture
*
* Return the angle delta in degrees between the last and the current @ref
* LIBINPUT_EVENT_GESTURE_PINCH_UPDATE event. For gesture events that
* are not of type @ref LIBINPUT_EVENT_GESTURE_PINCH_UPDATE, this
* function returns 0.
*
* The angle delta is defined as the change in angle of the line formed by
* the 2 fingers of a pinch gesture. Clockwise rotation is represented
* by a positive delta, counter-clockwise by a negative delta. If e.g. the
* fingers are on the 12 and 6 location of a clock face plate and they move
* to the 1 resp. 7 location in a single event then the angle delta is
* 30 degrees.
*
* If more than two fingers are present, the angle represents the rotation
* around the center of gravity. The calculation of the center of gravity is
* implementation-dependent.
*
* @return the angle delta since the last event
*/
libinput_event_gesture_get_angle_delta :: (event: *libinput_event_gesture) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* @return The generic libinput_event of this event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_base_event :: (event: *libinput_event_tablet_tool) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the x axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_x_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the y axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_y_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the pressure axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_pressure_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the distance axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
* For tablet tool events of type @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY,
* this function always returns 1.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_distance_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the tilt x axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_tilt_x_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the tilt y axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_tilt_y_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the z-rotation axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_rotation_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the slider axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_slider_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the size major axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*/
libinput_event_tablet_tool_size_major_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the size minor axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*/
libinput_event_tablet_tool_size_minor_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if the wheel axis was updated in this event.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS,
* @ref LIBINPUT_EVENT_TABLET_TOOL_TIP, or
* @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, this function returns 0.
*
* @note It is an application bug to call this function for events other
* than @ref LIBINPUT_EVENT_TABLET_TOOL_AXIS, @ref
* LIBINPUT_EVENT_TABLET_TOOL_TIP, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY, or @ref
* LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return 1 if the axis was updated or 0 otherwise
*
* @since 1.2
*/
libinput_event_tablet_tool_wheel_has_changed :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the X coordinate of the tablet tool, in mm from the top left
* corner of the tablet in its current logical orientation. Use
* libinput_event_tablet_tool_get_x_transformed() for transforming the axis
* value into a different coordinate space.
*
* If an area is defined for this device, the coordinate is in mm from
* the top left corner of the area. See
* libinput_device_config_area_set_rectangle() for details.
*
* @note On some devices, returned value may be negative or larger than the
* width of the device. See the libinput documentation for more details.
*
* @param event The libinput tablet tool event
* @return The current value of the the axis
*
* @since 1.2
*/
libinput_event_tablet_tool_get_x :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the Y coordinate of the tablet tool, in mm from the top left
* corner of the tablet in its current logical orientation. Use
* libinput_event_tablet_tool_get_y_transformed() for transforming the axis
* value into a different coordinate space.
*
* If an area is defined for this device, the coordinate is in mm from
* the top left corner of the area. See
* libinput_device_config_area_set_rectangle() for details.
*
* @note On some devices, returned value may be negative or larger than the
* width of the device. See the libinput documentation for more details.
*
* @param event The libinput tablet tool event
* @return The current value of the the axis
*
* @since 1.2
*/
libinput_event_tablet_tool_get_y :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the delta between the last event and the current event.
* If the tool employs pointer acceleration, the delta returned by this
* function is the accelerated delta.
*
* This value is in screen coordinate space, the delta is to be interpreted
* like the return value of libinput_event_pointer_get_dx().
* See the libinput documentation for more details.
*
* @param event The libinput tablet event
* @return The relative x movement since the last event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_dx :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the delta between the last event and the current event.
* If the tool employs pointer acceleration, the delta returned by this
* function is the accelerated delta.
*
* This value is in screen coordinate space, the delta is to be interpreted
* like the return value of libinput_event_pointer_get_dx().
* See the libinput documentation for more details.
*
* @param event The libinput tablet event
* @return The relative y movement since the last event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_dy :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current pressure being applied on the tool in use, normalized
* to the range [0, 1].
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the the axis
*
* @since 1.2
*/
libinput_event_tablet_tool_get_pressure :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current distance from the tablet's sensor, normalized to the
* range [0, 1].
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the the axis
*
* @since 1.2
*/
libinput_event_tablet_tool_get_distance :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current tilt along the X axis of the tablet's current logical
* orientation, in degrees off the tablet's z axis. That is, if the tool is
* perfectly orthogonal to the tablet, the tilt angle is 0. When the top
* tilts towards the logical top/left of the tablet, the x/y tilt angles are
* negative, if the top tilts towards the logical bottom/right of the
* tablet, the x/y tilt angles are positive.
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the axis in degrees
*
* @since 1.2
*/
libinput_event_tablet_tool_get_tilt_x :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current tilt along the Y axis of the tablet's current logical
* orientation, in degrees off the tablet's z axis. That is, if the tool is
* perfectly orthogonal to the tablet, the tilt angle is 0. When the top
* tilts towards the logical top/left of the tablet, the x/y tilt angles are
* negative, if the top tilts towards the logical bottom/right of the
* tablet, the x/y tilt angles are positive.
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the the axis in degrees
*
* @since 1.2
*/
libinput_event_tablet_tool_get_tilt_y :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current z rotation of the tool in degrees, clockwise from the
* tool's logical neutral position.
*
* For tools of type @ref LIBINPUT_TABLET_TOOL_TYPE_MOUSE and @ref
* LIBINPUT_TABLET_TOOL_TYPE_LENS the logical neutral position is
* pointing to the current logical north of the tablet. For tools of type @ref
* LIBINPUT_TABLET_TOOL_TYPE_BRUSH, the logical neutral position is with the
* buttons pointing up.
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the the axis
*
* @since 1.2
*/
libinput_event_tablet_tool_get_rotation :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current position of the slider on the tool, normalized to the
* range [-1, 1]. The logical zero is the neutral position of the slider, or
* the logical center of the axis. This axis is available on e.g. the Wacom
* Airbrush.
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the the axis
*
* @since 1.2
*/
libinput_event_tablet_tool_get_slider_position :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current size in mm along the major axis of the touching
* ellipse. This axis is not necessarily aligned with either x or y, the
* rotation must be taken into account.
*
* Where no rotation is available on a tool, or where rotation is zero, the
* major axis aligns with the y axis and the minor axis with the x axis.
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the axis major in mm
*/
libinput_event_tablet_tool_get_size_major :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the current size in mm along the minor axis of the touching
* ellipse. This axis is not necessarily aligned with either x or y, the
* rotation must be taken into account.
*
* Where no rotation is available on a tool, or where rotation is zero, the
* minor axis aligns with the y axis and the minor axis with the x axis.
*
* If this axis does not exist on the current tool, this function returns 0.
*
* @param event The libinput tablet tool event
* @return The current value of the axis minor in mm
*/
libinput_event_tablet_tool_get_size_minor :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the delta for the wheel in degrees.
*
* @param event The libinput tablet tool event
* @return The delta of the wheel, in degrees, compared to the last event
*
* @see libinput_event_tablet_tool_get_wheel_delta_discrete
*/
libinput_event_tablet_tool_get_wheel_delta :: (event: *libinput_event_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the delta for the wheel in discrete steps (e.g. wheel clicks).

* @param event The libinput tablet tool event
* @return The delta of the wheel, in discrete steps, compared to the last event
*
* @see libinput_event_tablet_tool_get_wheel_delta_discrete
*
* @since 1.2
*/
libinput_event_tablet_tool_get_wheel_delta_discrete :: (event: *libinput_event_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the current absolute x coordinate of the tablet tool event,
* transformed to screen coordinates.
*
* @note This function may be called for a specific axis even if
* libinput_event_tablet_tool_*_has_changed() returns 0 for that axis.
* libinput always includes all device axes in the event.
*
* @note On some devices, returned value may be negative or larger than the
* width of the device. See the libinput documentation for more details.
*
* @param event The libinput tablet tool event
* @param width The current output screen width
* @return the current absolute x coordinate transformed to a screen coordinate
*
* @since 1.2
*/
libinput_event_tablet_tool_get_x_transformed :: (event: *libinput_event_tablet_tool, width: u32) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the current absolute y coordinate of the tablet tool event,
* transformed to screen coordinates.
*
* @note This function may be called for a specific axis even if
* libinput_event_tablet_tool_*_has_changed() returns 0 for that axis.
* libinput always includes all device axes in the event.
*
* @note On some devices, returned value may be negative or larger than the
* width of the device. See the libinput documentation for more details.
*
* @param event The libinput tablet tool event
* @param height The current output screen height
* @return the current absolute y coordinate transformed to a screen coordinate
*
* @since 1.2
*/
libinput_event_tablet_tool_get_y_transformed :: (event: *libinput_event_tablet_tool, height: u32) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the tool that was in use during this event.
*
* The returned tablet tool is not refcounted and may become invalid after
* the next call to libinput. Use libinput_tablet_tool_ref() and
* libinput_tablet_tool_unref() to continue using the handle outside of the
* immediate scope.
*
* If the caller holds at least one reference, this struct is used
* whenever the tools enters proximity again.
*
* @note Physical tool tracking requires hardware support. If unavailable,
* libinput creates one tool per type per tablet. See
* libinput_tablet_tool_get_serial() for more details.
*
* @param event The libinput tablet tool event
* @return The new tool triggering this event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_tool :: (event: *libinput_event_tablet_tool) -> *libinput_tablet_tool #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the new proximity state of a tool from a proximity event.
* Used to check whether or not a tool came in or out of proximity during an
* event of type @ref LIBINPUT_EVENT_TABLET_TOOL_PROXIMITY.
*
* The proximity state represents the logical proximity state which does not
* necessarily match when a tool comes into sensor range or leaves the
* sensor range. On some tools this range does not represent the physical
* range but a reduced tool-specific logical range. If the range is reduced,
* this is done transparent to the caller.
*
* For example, the Wacom mouse and lens cursor tools are usually
* used in relative mode, lying flat on the tablet. Movement typically follows
* the interaction normal mouse movements have, i.e. slightly lift the tool and
* place it in a separate location. The proximity detection on Wacom
* tablets however extends further than the user may lift the mouse, i.e. the
* tool may not be lifted out of physical proximity. For such tools, libinput
* provides software-emulated proximity.
*
* @param event The libinput tablet tool event
* @return The new proximity state of the tool from the event.
*
* @since 1.2
*/
libinput_event_tablet_tool_get_proximity_state :: (event: *libinput_event_tablet_tool) -> libinput_tablet_tool_proximity_state #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Returns the new tip state of a tool from a tip event.
* Used to check whether or not a tool came in contact with the tablet
* surface or left contact with the tablet surface during an
* event of type @ref LIBINPUT_EVENT_TABLET_TOOL_TIP.
*
* @param event The libinput tablet tool event
* @return The new tip state of the tool from the event.
*
* @since 1.2
*/
libinput_event_tablet_tool_get_tip_state :: (event: *libinput_event_tablet_tool) -> libinput_tablet_tool_tip_state #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the button that triggered this event.  For events that are not of
* type @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return the button triggering this event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_button :: (event: *libinput_event_tablet_tool) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the button state of the event.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON.
*
* @param event The libinput tablet tool event
* @return the button state triggering this event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_button_state :: (event: *libinput_event_tablet_tool) -> libinput_button_state #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* For the button of a @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON event, return the total
* number of buttons pressed on all devices on the associated seat after the
* the event was triggered.
*
" @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_TOOL_BUTTON. For other events, this function returns 0.
*
* @param event The libinput tablet tool event
* @return the seat wide pressed button count for the key of this event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_seat_button_count :: (event: *libinput_event_tablet_tool) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @param event The libinput tablet tool event
* @return The event time for this event
*
* @since 1.2
*/
libinput_event_tablet_tool_get_time :: (event: *libinput_event_tablet_tool) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @param event The libinput tablet tool event
* @return The event time for this event in microseconds
*
* @since 1.2
*/
libinput_event_tablet_tool_get_time_usec :: (event: *libinput_event_tablet_tool) -> u64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the high-level tool type for a tool object.
*
* The high level tool describes general interaction expected with the tool.
* For example, a user would expect a tool of type @ref
* LIBINPUT_TABLET_TOOL_TYPE_PEN to interact with a graphics application
* taking pressure and tilt into account. The default virtual tool assigned
* should be a drawing tool, e.g. a virtual pen or brush.
* A tool of type @ref LIBINPUT_TABLET_TOOL_TYPE_ERASER would normally be
* mapped to an eraser-like virtual tool.
*
* If supported by the hardware, a more specific tool id is always
* available, see libinput_tablet_tool_get_tool_id().
*
* @param tool The libinput tool
* @return The tool type for this tool object
*
* @see libinput_tablet_tool_get_tool_id
*
* @since 1.2
*/
libinput_tablet_tool_get_type :: (tool: *libinput_tablet_tool) -> libinput_tablet_tool_type #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the tool ID for a tool object. If nonzero, this number identifies
* the specific type of the tool with more precision than the type returned in
* libinput_tablet_tool_get_type(). Not all tablets support a tool ID.
*
* Tablets known to support tool IDs include the Wacom Intuos 3, 4, 5, Wacom
* Cintiq and Wacom Intuos Pro series. The tool ID can be used to
* distinguish between e.g. a Wacom Classic Pen or a Wacom Pro Pen.  It is
* the caller's responsibility to interpret the tool ID.
*
* @param tool The libinput tool
* @return The tool ID for this tool object or 0 if none is provided
*
* @see libinput_tablet_tool_get_type
*
* @since 1.2
*/
libinput_tablet_tool_get_tool_id :: (tool: *libinput_tablet_tool) -> u64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Increment the reference count of the tool by one. A tool is destroyed
* whenever the reference count reaches 0. See libinput_tablet_tool_unref().
*
* @param tool The tool to increment the ref count of
* @return The passed tool
*
* @see libinput_tablet_tool_unref
*
* @since 1.2
*/
libinput_tablet_tool_ref :: (tool: *libinput_tablet_tool) -> *libinput_tablet_tool #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Decrement the reference count of the tool by one. When the reference
* count of the tool reaches 0, the memory allocated for the tool will be
* freed.
*
* @param tool The tool to decrement the ref count of
* @return NULL if the tool was destroyed otherwise the passed tool
*
* @see libinput_tablet_tool_ref
*
* @since 1.2
*/
libinput_tablet_tool_unref :: (tool: *libinput_tablet_tool) -> *libinput_tablet_tool #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return whether the tablet tool supports pressure.
*
* @param tool The tool to check the axis capabilities of
* @return Nonzero if the axis is available, zero otherwise.
*
* @since 1.2
*/
libinput_tablet_tool_has_pressure :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return whether the tablet tool supports distance.
*
* @param tool The tool to check the axis capabilities of
* @return Nonzero if the axis is available, zero otherwise.
*
* @since 1.2
*/
libinput_tablet_tool_has_distance :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return whether the tablet tool supports tilt.
*
* @param tool The tool to check the axis capabilities of
* @return Nonzero if the axis is available, zero otherwise.
*
* @since 1.2
*/
libinput_tablet_tool_has_tilt :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return whether the tablet tool supports z-rotation.
*
* @param tool The tool to check the axis capabilities of
* @return Nonzero if the axis is available, zero otherwise.
*
* @since 1.2
*/
libinput_tablet_tool_has_rotation :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return whether the tablet tool has a slider axis.
*
* @param tool The tool to check the axis capabilities of
* @return Nonzero if the axis is available, zero otherwise.
*
* @since 1.2
*/
libinput_tablet_tool_has_slider :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return whether the tablet tool has a ellipsis major and minor.
* Where the underlying hardware only supports one of either major or minor,
* libinput emulates the other axis as a circular contact, i.e. major ==
* minor for all values of major.
*
* @param tool The tool to check the axis capabilities of
* @return Nonzero if the axis is available, zero otherwise.
*/
libinput_tablet_tool_has_size :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return whether the tablet tool has a relative wheel.
*
* @param tool The tool to check the axis capabilities of
* @return Nonzero if the axis is available, zero otherwise.
*
* @since 1.2
*/
libinput_tablet_tool_has_wheel :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Check if a tablet tool has a button with the
* passed-in code (see linux/input.h).
*
* @param tool A tablet tool
* @param code button code to check for
*
* @return 1 if the tool supports this button code, 0 if it does not
*
* @since 1.2
*/
libinput_tablet_tool_has_button :: (tool: *libinput_tablet_tool, code: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return nonzero if the physical tool can be uniquely identified by
* libinput, or nonzero otherwise. If a tool can be uniquely identified,
* keeping a reference to the tool allows tracking the tool across
* proximity out sequences and across compatible tablets.
* See libinput_tablet_tool_get_serial() for more details.
*
* @param tool A tablet tool
* @return 1 if the tool can be uniquely identified, 0 otherwise.
*
* @see libinput_tablet_tool_get_serial
*
* @since 1.2
*/
libinput_tablet_tool_is_unique :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the serial number of a tool. If the tool does not report a serial
* number, this function returns zero.
*
* Some tools provide hardware information that enables libinput to uniquely
* identify the physical device. For example, tools compatible with the
* Wacom Intuos 4, Intuos 5, Intuos Pro and Cintiq series are uniquely
* identifiable through a serial number. libinput does not specify how a
* tool can be identified uniquely, a caller should use
* libinput_tablet_tool_is_unique() to check if the tool is unique.
*
* libinput creates a struct @ref libinput_tablet_tool on the first
* proximity in of this tool. By default, this struct is destroyed on
* proximity out and re-initialized on the next proximity in. If a caller
* keeps a reference to the tool by using libinput_tablet_tool_ref()
* libinput re-uses this struct whenever that same physical tool comes into
* proximity on any tablet
* recognized by libinput. It is possible to attach tool-specific virtual
* state to the tool. For example, a graphics program such as the GIMP may
* assign a specific color to each tool, allowing the artist to use the
* tools like physical pens of different color. In multi-tablet setups it is
* also possible to track the tool across devices.
*
* If the tool does not have a unique identifier, libinput creates a single
* struct @ref libinput_tablet_tool per tool type on each tablet the tool is
* used on.
*
* @param tool The libinput tool
* @return The tool serial number
*
* @see libinput_tablet_tool_is_unique
*
* @since 1.2
*/
libinput_tablet_tool_get_serial :: (tool: *libinput_tablet_tool) -> u64 #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Return the user data associated with a tool object. libinput does
* not manage, look at, or modify this data. The caller must ensure the
* data is valid.
*
* @param tool The libinput tool
* @return The user data associated with the tool object
*
* @since 1.2
*/
libinput_tablet_tool_get_user_data :: (tool: *libinput_tablet_tool) -> *void #foreign libinput_lib;

/**
* @ingroup event_tablet
*
* Set the user data associated with a tool object, if any.
*
* @param tool The libinput tool
* @param user_data The user data to associate with the tool object
*
* @since 1.2
*/
libinput_tablet_tool_set_user_data :: (tool: *libinput_tablet_tool, user_data: *void) -> void #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* @return The generic libinput_event of this event
*
* @since 1.3
*/
libinput_event_tablet_pad_get_base_event :: (event: *libinput_event_tablet_pad) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the current position of the ring, in degrees clockwise
* from the northern-most point of the ring in the tablet's current logical
* orientation.
*
* If the source is @ref LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER,
* libinput sends a terminating event with a ring value of -1 when the
* finger is lifted from the ring. A caller may use this information to e.g.
* determine if kinetic scrolling should be triggered.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The current value of the the axis
* @retval -1 The finger was lifted
*
* @since 1.3
*/
libinput_event_tablet_pad_get_ring_position :: (event: *libinput_event_tablet_pad) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the number of the ring that has changed state, with 0 being the
* first ring. On tablets with only one ring, this function always returns
* 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The index of the ring that changed state
*
* @since 1.3
*/
libinput_event_tablet_pad_get_ring_number :: (event: *libinput_event_tablet_pad) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the source of the interaction with the ring. If the source is
* @ref LIBINPUT_TABLET_PAD_RING_SOURCE_FINGER, libinput sends a ring
* position value of -1 to terminate the current interaction.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_RING.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The source of the ring interaction
*
* @since 1.3
*/
libinput_event_tablet_pad_get_ring_source :: (event: *libinput_event_tablet_pad) -> libinput_tablet_pad_ring_axis_source #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the current position of the strip, normalized to the range
* [0, 1], with 0 being the top/left-most point in the tablet's current
* logical orientation.
*
* If the source is @ref LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER,
* libinput sends a terminating event with a ring value of -1 when the
* finger is lifted from the ring. A caller may use this information to e.g.
* determine if kinetic scrolling should be triggered.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The current value of the the axis
* @retval -1 The finger was lifted
*
* @since 1.3
*/
libinput_event_tablet_pad_get_strip_position :: (event: *libinput_event_tablet_pad) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the number of the strip that has changed state, with 0 being the
* first strip. On tablets with only one strip, this function always returns
* 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The index of the strip that changed state
*
* @since 1.3
*/
libinput_event_tablet_pad_get_strip_number :: (event: *libinput_event_tablet_pad) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the source of the interaction with the strip. If the source is
* @ref LIBINPUT_TABLET_PAD_STRIP_SOURCE_FINGER, libinput sends a strip
* position value of -1 to terminate the current interaction.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_STRIP.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The source of the strip interaction
*
* @since 1.3
*/
libinput_event_tablet_pad_get_strip_source :: (event: *libinput_event_tablet_pad) -> libinput_tablet_pad_strip_axis_source #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Return the button number that triggered this event, starting at 0.
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON,
* this function returns 0.
*
* Note that the number returned is a generic sequential button number and
* not a semantic button code as defined in linux/input.h.
* See the libinput documentation for more details.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON. For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return the button triggering this event
*
* @since 1.3
*/
libinput_event_tablet_pad_get_button_number :: (event: *libinput_event_tablet_pad) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Return the button state of the event.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_BUTTON. For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return the button state triggering this event
*
* @since 1.3
*/
libinput_event_tablet_pad_get_button_state :: (event: *libinput_event_tablet_pad) -> libinput_button_state #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Return the key code that triggered this event, e.g. KEY_CONTROLPANEL. The
* list of key codes is defined in linux/input-event-codes.h.
*
* For events that are not of type @ref LIBINPUT_EVENT_TABLET_PAD_KEY,
* this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_KEY. For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return the key code triggering this event
*
* @since 1.15
*/
libinput_event_tablet_pad_get_key :: (event: *libinput_event_tablet_pad) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Return the key state of the event.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_KEY. For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return the key state triggering this event
*
* @since 1.15
*/
libinput_event_tablet_pad_get_key_state :: (event: *libinput_event_tablet_pad) -> libinput_key_state #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the delta change of the dial, in multiples or fractions of 120, with
* each multiple of 120 indicating one logical wheel event.
* See libinput_event_pointer_get_scroll_value_v120() for more details.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_DIAL.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The delta of the the axis
*
* @since 1.26
*/
libinput_event_tablet_pad_get_dial_delta_v120 :: (event: *libinput_event_tablet_pad) -> float64 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the number of the dial that has changed state, with 0 being the
* first dial. On tablets with only one dial, this function always returns
* 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_TABLET_PAD_DIAL.  For other events, this function
* returns 0.
*
* @param event The libinput tablet pad event
* @return The index of the dial that changed state
*
* @since 1.26
*/
libinput_event_tablet_pad_get_dial_number :: (event: *libinput_event_tablet_pad) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the mode the button, ring, or strip that triggered this event is
* in, at the time of the event.
*
* The mode is a virtual grouping of functionality, usually based on some
* visual feedback like LEDs on the pad. Mode indices start at 0, a device
* that does not support modes always returns 0.
*
* @note Pad keys are not part of a mode group. It is an application bug to
* call this function for @ref LIBINPUT_EVENT_TABLET_PAD_KEY.
*
* Mode switching is controlled by libinput and more than one mode may exist
* on the tablet. This function returns the mode that this event's button,
* ring or strip is logically in. If the button is a mode toggle button
* and the button event caused a new mode to be toggled, the mode returned
* is the new mode the button is in.
*
* Note that the returned mode is the mode valid as of the time of the
* event. The returned mode may thus be different to the mode returned by
* libinput_tablet_pad_mode_group_get_mode(). See
* libinput_tablet_pad_mode_group_get_mode() for details.
*
* @param event The libinput tablet pad event
* @return the 0-indexed mode of this button, ring or strip at the time of
* the event
*
* @see libinput_tablet_pad_mode_group_get_mode
*
* @since 1.4
*/
libinput_event_tablet_pad_get_mode :: (event: *libinput_event_tablet_pad) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* Returns the mode group that the button, ring, or strip that triggered
* this event is considered in. The mode is a virtual grouping of
* functionality, usually based on some visual feedback like LEDs on the
* pad.
*
* @note Pad keys are not part of a mode group. It is an application bug to
* call this function for @ref LIBINPUT_EVENT_TABLET_PAD_KEY.
*
* The returned mode group is not refcounted and may become invalid after
* the next call to libinput. Use libinput_tablet_pad_mode_group_ref() and
* libinput_tablet_pad_mode_group_unref() to continue using the handle
* outside of the immediate scope.
*
* @param event The libinput tablet pad event
* @return the mode group of the button, ring or strip that caused this event
*
* @see libinput_device_tablet_pad_get_mode_group
*
* @since 1.4
*/
libinput_event_tablet_pad_get_mode_group :: (event: *libinput_event_tablet_pad) -> *libinput_tablet_pad_mode_group #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @param event The libinput tablet pad event
* @return The event time for this event
*
* @since 1.3
*/
libinput_event_tablet_pad_get_time :: (event: *libinput_event_tablet_pad) -> u32 #foreign libinput_lib;

/**
* @ingroup event_tablet_pad
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @param event The libinput tablet pad event
* @return The event time for this event in microseconds
*
* @since 1.3
*/
libinput_event_tablet_pad_get_time_usec :: (event: *libinput_event_tablet_pad) -> u64 #foreign libinput_lib;

/**
* @ingroup event_switch
*
* Return the switch that triggered this event.
* For pointer events that are not of type @ref
* LIBINPUT_EVENT_SWITCH_TOGGLE, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_SWITCH_TOGGLE.
*
* @param event The libinput switch event
* @return The switch triggering this event
*
* @since 1.7
*/
libinput_event_switch_get_switch :: (event: *libinput_event_switch) -> libinput_switch #foreign libinput_lib;

/**
* @ingroup event_switch
*
* Return the switch state that triggered this event.
* For switch events that are not of type @ref
* LIBINPUT_EVENT_SWITCH_TOGGLE, this function returns 0.
*
* @note It is an application bug to call this function for events other than
* @ref LIBINPUT_EVENT_SWITCH_TOGGLE.
*
* @param event The libinput switch event
* @return The switch state triggering this event
*
* @since 1.7
*/
libinput_event_switch_get_switch_state :: (event: *libinput_event_switch) -> libinput_switch_state #foreign libinput_lib;

/**
* @ingroup event_switch
*
* @return The generic libinput_event of this event
*
* @since 1.7
*/
libinput_event_switch_get_base_event :: (event: *libinput_event_switch) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup event_switch
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @param event The libinput switch event
* @return The event time for this event
*
* @since 1.7
*/
libinput_event_switch_get_time :: (event: *libinput_event_switch) -> u32 #foreign libinput_lib;

/**
* @ingroup event_switch
*
* @note Timestamps may not always increase. See the libinput documentation
* for more details.
*
* @param event The libinput switch event
* @return The event time for this event in microseconds
*
* @since 1.7
*/
libinput_event_switch_get_time_usec :: (event: *libinput_event_switch) -> u64 #foreign libinput_lib;

/**
* @ingroup base
* @struct libinput_interface
*
* libinput does not open file descriptors to devices directly, instead
* open_restricted() and close_restricted() are called for each path that
* must be opened.
*
* @see libinput_udev_create_context
* @see libinput_path_create_context
*/
libinput_interface :: struct {
    /**
    * Open the device at the given path with the flags provided and
    * return the fd.
    *
    * @param path The device path to open
    * @param flags Flags as defined by open(2)
    * @param user_data The user_data provided in
    * libinput_udev_create_context()
    *
    * @return The file descriptor, or a negative errno on failure.
    */
    open_restricted:  #type (path: *u8, flags: s32, user_data: *void) -> s32 #c_call;

    /**
    * Close the file descriptor.
    *
    * @param fd The file descriptor to close
    * @param user_data The user_data provided in
    * libinput_udev_create_context()
    */
    close_restricted: #type (fd: s32, user_data: *void) -> void #c_call;
}

/**
* @ingroup base
*
* Create a new libinput context from udev. This context is inactive until
* assigned a seat ID with libinput_udev_assign_seat().
*
* @param interface The callback interface
* @param user_data Caller-specific data passed to the various callback
* interfaces.
* @param udev An already initialized udev context
*
* @return An initialized, but inactive libinput context or NULL on error
*/
libinput_udev_create_context :: (interface_: *libinput_interface, user_data: *void, udev_: *udev) -> *libinput #foreign libinput_lib;

/**
* @ingroup base
*
* Assign a seat to this libinput context. New devices or the removal of
* existing devices will appear as events during libinput_dispatch().
*
* libinput_udev_assign_seat() succeeds even if no input devices are currently
* available on this seat, or if devices are available but fail to open in
* @ref libinput_interface::open_restricted. Devices that do not have the
* minimum capabilities to be recognized as pointer, keyboard or touch
* device are ignored. Such devices and those that failed to open
* ignored until the next call to libinput_resume().
*
* This function may only be called once per context.
*
* @param libinput A libinput context initialized with
* libinput_udev_create_context()
* @param seat_id A seat identifier. This string must not be NULL.
*
* @return 0 on success or -1 on failure.
*/
libinput_udev_assign_seat :: (libinput_: *libinput, seat_id: *u8) -> s32 #foreign libinput_lib;

/**
* @ingroup base
*
* Create a new libinput context that requires the caller to manually add or
* remove devices with libinput_path_add_device() and
* libinput_path_remove_device().
*
* The context is fully initialized but will not generate events until at
* least one device has been added.
*
* The reference count of the context is initialized to 1. See @ref
* libinput_unref.
*
* @param interface The callback interface
* @param user_data Caller-specific data passed to the various callback
* interfaces.
*
* @return An initialized, empty libinput context.
*/
libinput_path_create_context :: (interface_: *libinput_interface, user_data: *void) -> *libinput #foreign libinput_lib;

/**
* @ingroup base
*
* Add a device to a libinput context initialized with
* libinput_path_create_context(). If successful, the device will be
* added to the internal list and re-opened on libinput_resume(). The device
* can be removed with libinput_path_remove_device().
*
* If the device was successfully initialized, it is returned in the device
* argument. The lifetime of the returned device pointer is limited until
* the next libinput_dispatch(), use libinput_device_ref() to keep a permanent
* reference.
*
* @param libinput A previously initialized libinput context
* @param path Path to an input device
* @return The newly initiated device on success, or NULL on failure.
*
* @note It is an application bug to call this function on a libinput
* context initialized with libinput_udev_create_context().
*/
libinput_path_add_device :: (libinput_: *libinput, path: *u8) -> *libinput_device #foreign libinput_lib;

/**
* @ingroup base
*
* Remove a device from a libinput context initialized with
* libinput_path_create_context() or added to such a context with
* libinput_path_add_device().
*
* Events already processed from this input device are kept in the queue,
* the @ref LIBINPUT_EVENT_DEVICE_REMOVED event marks the end of events for
* this device.
*
* If no matching device exists, this function does nothing.
*
* @param device A libinput device
*
* @note It is an application bug to call this function on a libinput
* context initialized with libinput_udev_create_context().
*/
libinput_path_remove_device :: (device: *libinput_device) -> void #foreign libinput_lib;

/**
* @ingroup base
*
* libinput keeps a single file descriptor for all events. Call into
* libinput_dispatch() if any events become available on this fd.
*
* @return The file descriptor used to notify of pending events.
*/
libinput_get_fd :: (libinput_: *libinput) -> s32 #foreign libinput_lib;

/**
* @ingroup base
*
* Main event dispatchment function. Reads events of the file descriptors
* and processes them internally. Use libinput_get_event() to retrieve the
* events.
*
* Dispatching does not necessarily queue libinput events. This function
* should be called immediately once data is available on the file
* descriptor returned by libinput_get_fd(). libinput has a number of
* timing-sensitive features (e.g. tap-to-click), any delay in calling
* libinput_dispatch() may prevent these features from working correctly.
*
* @param libinput A previously initialized libinput context
*
* @return 0 on success, or a negative errno on failure
*/
libinput_dispatch :: (libinput_: *libinput) -> s32 #foreign libinput_lib;

/**
* @ingroup base
*
* Retrieve the next event from libinput's internal event queue.
*
* After handling the retrieved event, the caller must destroy it using
* libinput_event_destroy().
*
* @param libinput A previously initialized libinput context
* @return The next available event, or NULL if no event is available.
*/
libinput_get_event :: (libinput_: *libinput) -> *libinput_event #foreign libinput_lib;

/**
* @ingroup base
*
* Return the type of the next event in the internal queue. This function
* does not pop the event off the queue and the next call to
* libinput_get_event() returns that event.
*
* @param libinput A previously initialized libinput context
* @return The event type of the next available event or @ref
* LIBINPUT_EVENT_NONE if no event is available.
*/
libinput_next_event_type :: (libinput_: *libinput) -> libinput_event_type #foreign libinput_lib;

/**
* @ingroup base
*
* Set caller-specific data associated with this context. libinput does
* not manage, look at, or modify this data. The caller must ensure the
* data is valid.
*
* @param libinput A previously initialized libinput context
* @param user_data Caller-specific data passed to the various callback
* interfaces.
*/
libinput_set_user_data :: (libinput_: *libinput, user_data: *void) -> void #foreign libinput_lib;

/**
* @ingroup base
*
* Get the caller-specific data associated with this context, if any.
*
* @param libinput A previously initialized libinput context
* @return The caller-specific data previously assigned in
* libinput_set_user_data(), libinput_path_create_context() or
* libinput_udev_create_context().
*/
libinput_get_user_data :: (libinput_: *libinput) -> *void #foreign libinput_lib;

/**
* @ingroup base
*
* Resume a suspended libinput context. This re-enables device
* monitoring and adds existing devices.
*
* @param libinput A previously initialized libinput context
* @see libinput_suspend
*
* @return 0 on success or -1 on failure
*/
libinput_resume :: (libinput_: *libinput) -> s32 #foreign libinput_lib;

/**
* @ingroup base
*
* Suspend monitoring for new devices and close existing devices.
* This all but terminates libinput but does keep the context
* valid to be resumed with libinput_resume().
*
* @param libinput A previously initialized libinput context
*/
libinput_suspend :: (libinput_: *libinput) -> void #foreign libinput_lib;

/**
* @ingroup base
*
* Add a reference to the context. A context is destroyed whenever the
* reference count reaches 0. See @ref libinput_unref.
*
* @param libinput A previously initialized valid libinput context
* @return The passed libinput context
*/
libinput_ref :: (libinput_: *libinput) -> *libinput #foreign libinput_lib;

/**
* @ingroup base
*
* Dereference the libinput context. After this, the context may have been
* destroyed, if the last reference was dereferenced. If so, the context is
* invalid and may not be interacted with.
*
* @bug When the refcount reaches zero, libinput_unref() releases resources
* even if a caller still holds refcounted references to related resources
* (e.g. a libinput_device). When libinput_unref() returns
* NULL, the caller must consider any resources related to that context
* invalid. See https://bugs.freedesktop.org/show_bug.cgi?id=91872.
*
* Example code:
* @code
* li = libinput_path_create_context(&interface, NULL);
* device = libinput_path_add_device(li, "/dev/input/event0");
* // get extra reference to device
* libinput_device_ref(device);
*
* // refcount reaches 0, so *all* resources are cleaned up,
* // including device
* libinput_unref(li);
*
* // INCORRECT: device has been cleaned up and must not be used
* // li = libinput_device_get_context(device);
* @endcode
*
* @param libinput A previously initialized libinput context
* @return NULL if context was destroyed otherwise the passed context
*/
libinput_unref :: (libinput_: *libinput) -> *libinput #foreign libinput_lib;

/**
* @ingroup base
*
* Set the log priority for the libinput context. Messages with priorities
* equal to or higher than the argument will be printed to the context's
* log handler.
*
* The default log priority is @ref LIBINPUT_LOG_PRIORITY_ERROR.
*
* @param libinput A previously initialized libinput context
* @param priority The minimum priority of log messages to print.
*
* @see libinput_log_set_handler
* @see libinput_log_get_priority
*/
libinput_log_set_priority :: (libinput_: *libinput, priority: libinput_log_priority) -> void #foreign libinput_lib;

/**
* @ingroup base
*
* Get the context's log priority. Messages with priorities equal to or
* higher than the argument will be printed to the current log handler.
*
* The default log priority is @ref LIBINPUT_LOG_PRIORITY_ERROR.
*
* @param libinput A previously initialized libinput context
* @return The minimum priority of log messages to print.
*
* @see libinput_log_set_handler
* @see libinput_log_set_priority
*/
libinput_log_get_priority :: (libinput_: *libinput) -> libinput_log_priority #foreign libinput_lib;

/**
* @ingroup base
*
* Log handler type for custom logging.
*
* @param libinput The libinput context
* @param priority The priority of the current message
* @param format Message format in printf-style
* @param args Message arguments
*
* @see libinput_log_set_priority
* @see libinput_log_get_priority
* @see libinput_log_set_handler
*/
libinput_log_handler :: *void /* function type contained C va_list argument */;

/**
* @ingroup base
*
* Set the context's log handler. Messages with priorities equal to or
* higher than the context's log priority will be passed to the given
* log handler.
*
* The default log handler prints to stderr.
*
* @param libinput A previously initialized libinput context
* @param log_handler The log handler for library messages.
*
* @see libinput_log_set_priority
* @see libinput_log_get_priority
*/
libinput_log_set_handler :: (libinput_: *libinput, log_handler: libinput_log_handler) -> void #foreign libinput_lib;

/**
* @ingroup seat
*
* Increase the refcount of the seat. A seat will be freed whenever the
* refcount reaches 0. This may happen during libinput_dispatch() if the
* seat was removed from the system. A caller must ensure to reference
* the seat correctly to avoid dangling pointers.
*
* @param seat A previously obtained seat
* @return The passed seat
*/
libinput_seat_ref :: (seat: *libinput_seat) -> *libinput_seat #foreign libinput_lib;

/**
* @ingroup seat
*
* Decrease the refcount of the seat. A seat will be freed whenever the
* refcount reaches 0. This may happen during libinput_dispatch() if the
* seat was removed from the system. A caller must ensure to reference
* the seat correctly to avoid dangling pointers.
*
* @param seat A previously obtained seat
* @return NULL if seat was destroyed, otherwise the passed seat
*/
libinput_seat_unref :: (seat: *libinput_seat) -> *libinput_seat #foreign libinput_lib;

/**
* @ingroup seat
*
* Set caller-specific data associated with this seat. libinput does
* not manage, look at, or modify this data. The caller must ensure the
* data is valid.
*
* @param seat A previously obtained seat
* @param user_data Caller-specific data pointer
* @see libinput_seat_get_user_data
*/
libinput_seat_set_user_data :: (seat: *libinput_seat, user_data: *void) -> void #foreign libinput_lib;

/**
* @ingroup seat
*
* Get the caller-specific data associated with this seat, if any.
*
* @param seat A previously obtained seat
* @return Caller-specific data pointer or NULL if none was set
* @see libinput_seat_set_user_data
*/
libinput_seat_get_user_data :: (seat: *libinput_seat) -> *void #foreign libinput_lib;

/**
* @ingroup seat
*
* Get the libinput context from the seat.
*
* @param seat A previously obtained seat
* @return The libinput context for this seat.
*/
libinput_seat_get_context :: (seat: *libinput_seat) -> *libinput #foreign libinput_lib;

/**
* @ingroup seat
*
* Return the physical name of the seat. For libinput contexts created from
* udev, this is always the same value as passed into
* libinput_udev_assign_seat() and all seats from that context will have
* the same physical name.
*
* The physical name of the seat is one that is usually set by the system or
* lower levels of the stack. In most cases, this is the base filter for
* devices - devices assigned to seats outside the current seat will not
* be available to the caller.
*
* @param seat A previously obtained seat
* @return The physical name of this seat
*/
libinput_seat_get_physical_name :: (seat: *libinput_seat) -> *u8 #foreign libinput_lib;

/**
* @ingroup seat
*
* Return the logical name of the seat. This is an identifier to group sets
* of devices within the compositor.
*
* @param seat A previously obtained seat
* @return The logical name of this seat
*/
libinput_seat_get_logical_name :: (seat: *libinput_seat) -> *u8 #foreign libinput_lib;

/**
* @ingroup device
*
* Increase the refcount of the input device. An input device will be freed
* whenever the refcount reaches 0. This may happen during
* libinput_dispatch() if the device was removed from the system. A caller
* must ensure to reference the device correctly to avoid dangling pointers.
*
* @param device A previously obtained device
* @return The passed device
*/
libinput_device_ref :: (device: *libinput_device) -> *libinput_device #foreign libinput_lib;

/**
* @ingroup device
*
* Decrease the refcount of the input device. An input device will be freed
* whenever the refcount reaches 0. This may happen during libinput_dispatch
* if the device was removed from the system. A caller must ensure to
* reference the device correctly to avoid dangling pointers.
*
* @param device A previously obtained device
* @return NULL if the device was destroyed, otherwise the passed device
*/
libinput_device_unref :: (device: *libinput_device) -> *libinput_device #foreign libinput_lib;

/**
* @ingroup device
*
* Set caller-specific data associated with this input device. libinput does
* not manage, look at, or modify this data. The caller must ensure the
* data is valid.
*
* @param device A previously obtained device
* @param user_data Caller-specific data pointer
* @see libinput_device_get_user_data
*/
libinput_device_set_user_data :: (device: *libinput_device, user_data: *void) -> void #foreign libinput_lib;

/**
* @ingroup device
*
* Get the caller-specific data associated with this input device, if any.
*
* @param device A previously obtained device
* @return Caller-specific data pointer or NULL if none was set
* @see libinput_device_set_user_data
*/
libinput_device_get_user_data :: (device: *libinput_device) -> *void #foreign libinput_lib;

/**
* @ingroup device
*
* Get the libinput context from the device.
*
* @param device A previously obtained device
* @return The libinput context for this device.
*/
libinput_device_get_context :: (device: *libinput_device) -> *libinput #foreign libinput_lib;

/**
* @ingroup device
*
* Get the device group this device is assigned to. Some physical
* devices like graphics tablets are represented by multiple kernel
* devices and thus by multiple struct @ref libinput_device.
*
* libinput assigns these devices to the same @ref libinput_device_group
* allowing the caller to identify such devices and adjust configuration
* settings accordingly. For example, setting a tablet to left-handed often
* means turning it upside down. A touch device on the same tablet would
* need to be turned upside down too to work correctly.
*
* All devices are part of a device group though for most devices the group
* will be a singleton. A device is assigned to a device group on @ref
* LIBINPUT_EVENT_DEVICE_ADDED and removed from that group on @ref
* LIBINPUT_EVENT_DEVICE_REMOVED. It is up to the caller to track how many
* devices are in each device group.
*
* @dot
* digraph groups_libinput {
*   rankdir="TB";
*   node [
*     shape="box";
*   ]
*
*   mouse [ label="mouse"; URL="\ref libinput_device"];
*   kbd [ label="keyboard"; URL="\ref libinput_device"];
*
*   pen [ label="tablet pen"; URL="\ref libinput_device"];
*   touch [ label="tablet touch"; URL="\ref libinput_device"];
*   pad [ label="tablet pad"; URL="\ref libinput_device"];
*
*   group1 [ label="group 1"; URL="\ref libinput_device_group"];
*   group2 [ label="group 2"; URL="\ref libinput_device_group"];
*   group3 [ label="group 3"; URL="\ref libinput_device_group"];
*
*   mouse -> group1
*   kbd -> group2
*
*   pen -> group3;
*   touch -> group3;
*   pad -> group3;
* }
* @enddot
*
* Device groups do not get re-used once the last device in the group was
* removed, i.e. unplugging and re-plugging a physical device with grouped
* devices will return a different device group after every unplug.
*
* The returned device group is not refcounted and may become invalid after
* the next call to libinput. Use libinput_device_group_ref() and
* libinput_device_group_unref() to continue using the handle outside of the
* immediate scope.
*
* Device groups are assigned based on the <b>LIBINPUT_DEVICE_GROUP</b> udev
* property, see the libinput documentation for more details.
*
* @return The device group this device belongs to
*/
libinput_device_get_device_group :: (device: *libinput_device) -> *libinput_device_group #foreign libinput_lib;

/**
* @ingroup device
*
* Get the system name of the device.
*
* To get the descriptive device name, use libinput_device_get_name().
*
* @param device A previously obtained device
* @return System name of the device
*
*/
libinput_device_get_sysname :: (device: *libinput_device) -> *u8 #foreign libinput_lib;

/**
* @ingroup device
*
* The descriptive device name as advertised by the kernel and/or the
* hardware itself. To get the sysname for this device, use
* libinput_device_get_sysname().
*
* The lifetime of the returned string is tied to the struct
* libinput_device. The string may be the empty string but is never NULL.
*
* @param device A previously obtained device
* @return The device name
*/
libinput_device_get_name :: (device: *libinput_device) -> *u8 #foreign libinput_lib;

/**
* @ingroup device
*
* Get the bus type ID for this device.
*
* @param device A previously obtained device
* @return The bus type ID of this device (see BUS_* in linux/input.h)
*
* @since 1.26
*/
libinput_device_get_id_bustype :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup device
*
* Get the product ID for this device.
*
* @param device A previously obtained device
* @return The product ID of this device
*/
libinput_device_get_id_product :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup device
*
* Get the vendor ID for this device.
*
* @param device A previously obtained device
* @return The vendor ID of this device
*/
libinput_device_get_id_vendor :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup device
*
* A device may be mapped to a single output, or all available outputs. If a
* device is mapped to a single output only, a relative device may not move
* beyond the boundaries of this output. An absolute device has its input
* coordinates mapped to the extents of this output.
*
* @note <b>Use of this function is discouraged.</b> Its return value is not
* precisely defined and may not be understood by the caller or may be
* insufficient to map the device. Instead, the system configuration could
* set a udev property the caller understands and interprets correctly. The
* caller could then obtain device with libinput_device_get_udev_device()
* and query it for this property. For more complex cases, the caller
* must implement monitor-to-device association heuristics.
*
* @return The name of the output this device is mapped to, or NULL if no
* output is set
*/
libinput_device_get_output_name :: (device: *libinput_device) -> *u8 #foreign libinput_lib;

/**
* @ingroup device
*
* Get the seat associated with this input device.
*
* A seat can be uniquely identified by the physical and logical seat name.
* There will ever be only one seat instance with a given physical and logical
* seat name pair at any given time, but if no external reference is kept, it
* may be destroyed if no device belonging to it is left.
*
* The returned seat is not refcounted and may become invalid after
* the next call to libinput. Use libinput_seat_ref() and
* libinput_seat_unref() to continue using the handle outside of the
* immediate scope.
*
* See the libinput documentation for more information on seats.
*
* @param device A previously obtained device
* @return The seat this input device belongs to
*/
libinput_device_get_seat :: (device: *libinput_device) -> *libinput_seat #foreign libinput_lib;

/**
* @ingroup device
*
* Change the logical seat associated with this device by removing the
* device and adding it to the new seat.
*
* This command is identical to physically unplugging the device, then
* re-plugging it as a member of the new seat. libinput will generate a
* @ref LIBINPUT_EVENT_DEVICE_REMOVED event and this @ref libinput_device is
* considered removed from the context; it will not generate further events
* and will be freed when the refcount reaches zero.
* A @ref LIBINPUT_EVENT_DEVICE_ADDED event is generated with a new @ref
* libinput_device handle. It is the caller's responsibility to update
* references to the new device accordingly.
*
* If the logical seat name already exists in the device's physical seat,
* the device is added to this seat. Otherwise, a new seat is created.
*
* @note This change applies to this device until removal or @ref
* libinput_suspend(), whichever happens earlier.
*
* @param device A previously obtained device
* @param name The new logical seat name
* @return 0 on success, non-zero on error
*/
libinput_device_set_seat_logical_name :: (device: *libinput_device, name: *u8) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Return a udev handle to the device that is this libinput device, if any.
* The returned handle has a refcount of at least 1, the caller must call
* <i>udev_device_unref()</i> once to release the associated resources.
* See the [libudev documentation]
* (http://www.freedesktop.org/software/systemd/libudev/) for details.
*
* Some devices may not have a udev device, or the udev device may be
* unobtainable. This function returns NULL if no udev device was available.
*
* Calling this function multiple times for the same device may not
* return the same udev handle each time.
*
* @param device A previously obtained device
* @return A udev handle to the device with a refcount of >= 1 or NULL.
* @retval NULL This device is not represented by a udev device
*/
libinput_device_get_udev_device :: (device: *libinput_device) -> *udev_device #foreign libinput_lib;

/**
* @ingroup device
*
* Update the LEDs on the device, if any. If the device does not have
* LEDs, or does not have one or more of the LEDs given in the mask, this
* function does nothing.
*
* @param device A previously obtained device
* @param leds A mask of the LEDs to set, or unset.
*/
libinput_device_led_update :: (device: *libinput_device, leds: libinput_led) -> void #foreign libinput_lib;

/**
* @ingroup device
*
* Check if the given device has the specified capability
*
* @return Non-zero if the given device has the capability or zero otherwise
*/
libinput_device_has_capability :: (device: *libinput_device, capability: libinput_device_capability) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Get the physical size of a device in mm, where meaningful. This function
* only succeeds on devices with the required data, i.e. tablets, touchpads
* and touchscreens.
*
* If this function returns nonzero, width and height are unmodified.
*
* @param device The device
* @param width Set to the width of the device
* @param height Set to the height of the device
* @return 0 on success, or nonzero otherwise
*/
libinput_device_get_size :: (device: *libinput_device, width: *float64, height: *float64) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Check if a @ref LIBINPUT_DEVICE_CAP_POINTER device has a button with the
* given code (see linux/input-event-codes.h).
*
* @param device A current input device
* @param code Button code to check for, e.g. <i>BTN_LEFT</i>
*
* @return 1 if the device supports this button code, 0 if it does not, -1
* on error.
*/
libinput_device_pointer_has_button :: (device: *libinput_device, code: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Check if a @ref LIBINPUT_DEVICE_CAP_KEYBOARD device has a key with the
* given code (see linux/input-event-codes.h).
*
* @param device A current input device
* @param code Key code to check for, e.g. <i>KEY_ESC</i>
*
* @return 1 if the device supports this key code, 0 if it does not, -1
* on error.
*/
libinput_device_keyboard_has_key :: (device: *libinput_device, code: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Check how many touches a @ref LIBINPUT_DEVICE_CAP_TOUCH device supports
* simultaneously.
*
* @param device A current input device
*
* @return The number of simultaneous touches or 0 if unknown, -1
* on error.
*
* @since 1.11
*/
libinput_device_touch_get_touch_count :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Check if a @ref LIBINPUT_DEVICE_CAP_SWITCH device has a switch of the
* given type.
*
* @param device A current input device
* @param sw Switch to check for
*
* @return 1 if the device supports this switch, 0 if it does not, -1
* on error.
*
* @since 1.9
*/
libinput_device_switch_has_switch :: (device: *libinput_device, sw: libinput_switch) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Return the number of buttons on a device with the
* @ref LIBINPUT_DEVICE_CAP_TABLET_PAD capability.
* Buttons on a pad device are numbered sequentially, see the
* libinput documentation for details.
*
* @param device A current input device
*
* @return The number of buttons supported by the device. -1 on error.
*
* @since 1.3
*/
libinput_device_tablet_pad_get_num_buttons :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Return the number of dials a device with the @ref
* LIBINPUT_DEVICE_CAP_TABLET_PAD capability provides.
*
* @param device A current input device
*
* @return The number of dials or 0 if the device has no dials. -1 on error.
*
* @see libinput_event_tablet_pad_get_dial_number
*
* @since 1.26
*/
libinput_device_tablet_pad_get_num_dials :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Return the number of rings a device with the @ref
* LIBINPUT_DEVICE_CAP_TABLET_PAD capability provides.
*
* @param device A current input device
*
* @return The number of rings or 0 if the device has no rings. -1 on error.
*
* @see libinput_event_tablet_pad_get_ring_number
*
* @since 1.3
*/
libinput_device_tablet_pad_get_num_rings :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Return the number of strips a device with the @ref
* LIBINPUT_DEVICE_CAP_TABLET_PAD capability provides.
*
* @param device A current input device
*
* @return The number of strips or 0 if the device has no strips. -1 on error.
*
* @see libinput_event_tablet_pad_get_strip_number
*
* @since 1.3
*/
libinput_device_tablet_pad_get_num_strips :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Check if a @ref LIBINPUT_DEVICE_CAP_TABLET_PAD device has a key with the
* given code (see linux/input-event-codes.h).
*
* @param device A current input device
* @param code Key code to check for, e.g. <i>KEY_ESC</i>
*
* @return 1 if the device supports this key code, 0 if it does not, -1
* on error.
*
* @since 1.15
*/
libinput_device_tablet_pad_has_key :: (device: *libinput_device, code: u32) -> s32 #foreign libinput_lib;

/**
* @ingroup device
*
* Increase the refcount of the device group. A device group will be freed
* whenever the refcount reaches 0. This may happen during
* libinput_dispatch() if all devices of this group were removed from the
* system. A caller must ensure to reference the device group correctly to
* avoid dangling pointers.
*
* @param group A previously obtained device group
* @return The passed device group
*/
libinput_device_group_ref :: (group: *libinput_device_group) -> *libinput_device_group #foreign libinput_lib;

/**
* @ingroup device
*
* Decrease the refcount of the device group. A device group will be freed
* whenever the refcount reaches 0. This may happen during
* libinput_dispatch() if all devices of this group were removed from the
* system. A caller must ensure to reference the device group correctly to
* avoid dangling pointers.
*
* @param group A previously obtained device group
* @return NULL if the device group was destroyed, otherwise the passed
* device group
*/
libinput_device_group_unref :: (group: *libinput_device_group) -> *libinput_device_group #foreign libinput_lib;

/**
* @ingroup device
*
* Set caller-specific data associated with this device group. libinput does
* not manage, look at, or modify this data. The caller must ensure the
* data is valid.
*
* @param group A previously obtained device group
* @param user_data Caller-specific data pointer
* @see libinput_device_group_get_user_data
*/
libinput_device_group_set_user_data :: (group: *libinput_device_group, user_data: *void) -> void #foreign libinput_lib;

/**
* @ingroup device
*
* Get the caller-specific data associated with this input device group, if
* any.
*
* @param group A previously obtained group
* @return Caller-specific data pointer or NULL if none was set
* @see libinput_device_group_set_user_data
*/
libinput_device_group_get_user_data :: (group: *libinput_device_group) -> *void #foreign libinput_lib;

/**
* @ingroup config
*
* Status codes returned when applying configuration settings.
*/
libinput_config_status :: enum u32 {
    SUCCESS     :: 0;
    UNSUPPORTED :: 1;
    INVALID     :: 2;

    LIBINPUT_CONFIG_STATUS_SUCCESS     :: SUCCESS;
    LIBINPUT_CONFIG_STATUS_UNSUPPORTED :: UNSUPPORTED;
    LIBINPUT_CONFIG_STATUS_INVALID     :: INVALID;
}

/**
* @ingroup config
*
* Return a string describing the error.
*
* @param status The status to translate to a string
* @return A human-readable string representing the error or NULL for an
* invalid status.
*/
libinput_config_status_to_str :: (status: libinput_config_status) -> *u8 #foreign libinput_lib;

/**
* @ingroup config
*/
libinput_config_tap_state :: enum u32 {
    DISABLED :: 0;
    ENABLED  :: 1;

    LIBINPUT_CONFIG_TAP_DISABLED :: DISABLED;
    LIBINPUT_CONFIG_TAP_ENABLED  :: ENABLED;
}

/**
* @ingroup config
*
* Check if the device supports tap-to-click and how many fingers can be
* used for tapping. See
* libinput_device_config_tap_set_enabled() for more information.
*
* @param device The device to configure
* @return The number of fingers that can generate a tap event, or 0 if the
* device does not support tapping.
*
* @see libinput_device_config_tap_set_enabled
* @see libinput_device_config_tap_get_enabled
* @see libinput_device_config_tap_get_default_enabled
*/
libinput_device_config_tap_get_finger_count :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Enable or disable tap-to-click on this device, with a default mapping of
* 1, 2, 3 finger tap mapping to left, right, middle click, respectively.
* Tapping is limited by the number of simultaneous touches
* supported by the device, see
* libinput_device_config_tap_get_finger_count().
*
* @param device The device to configure
* @param enable @ref LIBINPUT_CONFIG_TAP_ENABLED to enable tapping or @ref
* LIBINPUT_CONFIG_TAP_DISABLED to disable tapping
*
* @return A config status code. Disabling tapping on a device that does not
* support tapping always succeeds.
*
* @see libinput_device_config_tap_get_finger_count
* @see libinput_device_config_tap_get_enabled
* @see libinput_device_config_tap_get_default_enabled
*/
libinput_device_config_tap_set_enabled :: (device: *libinput_device, enable: libinput_config_tap_state) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Check if tap-to-click is enabled on this device. If the device does not
* support tapping, this function always returns @ref
* LIBINPUT_CONFIG_TAP_DISABLED.
*
* @param device The device to configure
*
* @retval LIBINPUT_CONFIG_TAP_ENABLED If tapping is currently enabled
* @retval LIBINPUT_CONFIG_TAP_DISABLED If tapping is currently disabled
*
* @see libinput_device_config_tap_get_finger_count
* @see libinput_device_config_tap_set_enabled
* @see libinput_device_config_tap_get_default_enabled
*/
libinput_device_config_tap_get_enabled :: (device: *libinput_device) -> libinput_config_tap_state #foreign libinput_lib;

/**
* @ingroup config
*
* Return the default setting for whether tap-to-click is enabled on this
* device.
*
* @param device The device to configure
* @retval LIBINPUT_CONFIG_TAP_ENABLED If tapping is enabled by default
* @retval LIBINPUT_CONFIG_TAP_DISABLED If tapping Is disabled by default
*
* @see libinput_device_config_tap_get_finger_count
* @see libinput_device_config_tap_set_enabled
* @see libinput_device_config_tap_get_enabled
*/
libinput_device_config_tap_get_default_enabled :: (device: *libinput_device) -> libinput_config_tap_state #foreign libinput_lib;

/**
* @ingroup config
*
* @since 1.5
*/
libinput_config_tap_button_map :: enum u32 {
    LRM :: 0;
    LMR :: 1;

    LIBINPUT_CONFIG_TAP_MAP_LRM :: LRM;
    LIBINPUT_CONFIG_TAP_MAP_LMR :: LMR;
}

/**
* @ingroup config
*/
libinput_config_clickfinger_button_map :: enum u32 {
    LRM :: 0;
    LMR :: 1;

    LIBINPUT_CONFIG_CLICKFINGER_MAP_LRM :: LRM;
    LIBINPUT_CONFIG_CLICKFINGER_MAP_LMR :: LMR;
}

/**
* @ingroup config
*
* Set the finger number to button number mapping for tap-to-click. The
* default mapping on most devices is to have a 1, 2 and 3 finger tap to map
* to the left, right and middle button, respectively.
* A device may permit changing the button mapping but disallow specific
* maps. In this case @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED is returned,
* the caller is expected to handle this case correctly.
*
* Changing the button mapping may not take effect immediately,
* the device may wait until it is in a neutral state before applying any
* changes.
*
* The mapping may be changed when tap-to-click is disabled. The new mapping
* takes effect when tap-to-click is enabled in the future.
*
* @note It is an application bug to call this function for devices where
* libinput_device_config_tap_get_finger_count() returns 0.
*
* @param device The device to configure
* @param map The new finger-to-button number mapping
* @return A config status code. Changing the order on a device that does not
* support tapping always fails with @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED.
*
* @see libinput_device_config_tap_get_button_map
* @see libinput_device_config_tap_get_default_button_map
*
* @since 1.5
*/
libinput_device_config_tap_set_button_map :: (device: *libinput_device, map: libinput_config_tap_button_map) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the finger number to button number mapping for tap-to-click.
*
* The return value for a device that does not support tapping is always
* @ref LIBINPUT_CONFIG_TAP_MAP_LRM.
*
* @note It is an application bug to call this function for devices where
* libinput_device_config_tap_get_finger_count() returns 0.
*
* @param device The device to configure
* @return The current finger-to-button number mapping
*
* @see libinput_device_config_tap_set_button_map
* @see libinput_device_config_tap_get_default_button_map
*
* @since 1.5
*/
libinput_device_config_tap_get_button_map :: (device: *libinput_device) -> libinput_config_tap_button_map #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default finger number to button number mapping for tap-to-click.
*
* The return value for a device that does not support tapping is always
* @ref LIBINPUT_CONFIG_TAP_MAP_LRM.
*
* @note It is an application bug to call this function for devices where
* libinput_device_config_tap_get_finger_count() returns 0.
*
* @param device The device to configure
* @return The current finger-to-button number mapping
*
* @see libinput_device_config_tap_set_button_map
* @see libinput_device_config_tap_get_default_button_map
*
* @since 1.5
*/
libinput_device_config_tap_get_default_button_map :: (device: *libinput_device) -> libinput_config_tap_button_map #foreign libinput_lib;

/**
* @ingroup config
*
* A config status to distinguish or set dragging on a device. Currently
* implemented for tap-and-drag only, see
* libinput_device_config_tap_set_drag_enabled()
*
* @since 1.2
*/
libinput_config_drag_state :: enum u32 {
    DISABLED :: 0;
    ENABLED  :: 1;

    LIBINPUT_CONFIG_DRAG_DISABLED :: DISABLED;
    LIBINPUT_CONFIG_DRAG_ENABLED  :: ENABLED;
}

/**
* @ingroup config
*
* Enable or disable tap-and-drag on this device. When enabled, a
* tap immediately followed by a finger down results in a button down event,
* subsequent finger motion thus triggers a drag. The button is released
* on finger up. See the libinput documentation for more details.
*
* @param device The device to configure
* @param enable @ref LIBINPUT_CONFIG_DRAG_ENABLED to enable, @ref
* LIBINPUT_CONFIG_DRAG_DISABLED to disable tap-and-drag
*
* @see libinput_device_config_tap_get_drag_enabled
* @see libinput_device_config_tap_get_default_drag_enabled
*
* @since 1.2
*/
libinput_device_config_tap_set_drag_enabled :: (device: *libinput_device, enable: libinput_config_drag_state) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Return whether tap-and-drag is enabled or disabled on this device.
*
* @param device The device to check
* @retval LIBINPUT_CONFIG_DRAG_ENABLED if tap-and-drag is enabled
* @retval LIBINPUT_CONFIG_DRAG_DISABLED if tap-and-drag is
* disabled
*
* @see libinput_device_config_tap_set_drag_enabled
* @see libinput_device_config_tap_get_default_default_enabled
*
* @since 1.2
*/
libinput_device_config_tap_get_drag_enabled :: (device: *libinput_device) -> libinput_config_drag_state #foreign libinput_lib;

/**
* @ingroup config
*
* Return whether tap-and-drag is enabled or disabled by default on this
* device.
*
* @param device The device to check
* @retval LIBINPUT_CONFIG_DRAG_ENABLED if tap-and-drag is enabled by
* default
* @retval LIBINPUT_CONFIG_DRAG_DISABLED if tap-and-drag is
* disabled by default
*
* @see libinput_device_config_tap_set_drag_enabled
* @see libinput_device_config_tap_get_drag_enabled
*
* @since 1.2
*/
libinput_device_config_tap_get_default_drag_enabled :: (device: *libinput_device) -> libinput_config_drag_state #foreign libinput_lib;

/**
* @ingroup config
*/
libinput_config_drag_lock_state :: enum u32 {
    DISABLED        :: 0;
    ENABLED_TIMEOUT :: 1;
    ENABLED         :: 1;
    ENABLED_STICKY  :: 2;

    LIBINPUT_CONFIG_DRAG_LOCK_DISABLED        :: DISABLED;
    LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_TIMEOUT :: ENABLED_TIMEOUT;
    LIBINPUT_CONFIG_DRAG_LOCK_ENABLED         :: ENABLED;
    LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_STICKY  :: ENABLED_STICKY;
}

/**
* @ingroup config
*
* Enable or disable drag-lock during tapping on this device. When enabled,
* a finger may be lifted and put back on the touchpad and the drag process
* continues. A timeout for lifting the finger is optional. When disabled,
* lifting the finger during a tap-and-drag will immediately stop the drag.
* See the libinput documentation for more details.
*
* Enabling drag lock on a device that has tapping or tap-and-drag disabled is
* permitted, but has no effect until tapping and tap-and-drag are enabled.
*
* @param device The device to configure
* @param enable @ref LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_STICKY to enable drag
* lock in sticky mode,
* @ref LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_TIMEOUT to enable drag lock in timeout
* mode,
* or @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED to disable drag lock
*
* @return A config status code. Disabling drag lock on a device that does not
* support tapping always succeeds.
*
* @see libinput_device_config_tap_get_drag_lock_enabled
* @see libinput_device_config_tap_get_default_drag_lock_enabled
*/
libinput_device_config_tap_set_drag_lock_enabled :: (device: *libinput_device, enable: libinput_config_drag_lock_state) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Check if drag-lock during tapping is enabled on this device. If the
* device does not support tapping, this function always returns
* @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED.
*
* Drag lock may be enabled even when tapping or tap-and-drag is disabled.
*
* @param device The device to configure
*
* @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_STICKY If drag lock is currently
* enabled in sticky mode
* @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_TIMEOUT If drag lock is currently
* enabled in timeout mode
* @retval LIBINPUT_CONFIG_DRAG_LOCK_DISABLED If drag lock is currently disabled
*
* @see libinput_device_config_tap_set_drag_lock_enabled
* @see libinput_device_config_tap_get_default_drag_lock_enabled
*/
libinput_device_config_tap_get_drag_lock_enabled :: (device: *libinput_device) -> libinput_config_drag_lock_state #foreign libinput_lib;

/**
* @ingroup config
*
* Check if drag-lock during tapping is enabled by default on this device.
* If the device does not support tapping, this function always returns
* @ref LIBINPUT_CONFIG_DRAG_LOCK_DISABLED.
*
* Drag lock may be enabled by default even when tapping or tap-and-drag is
* disabled by default.
*
* @param device The device to configure
*
* @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_STICKY If drag lock is enabled in
* sticky mode by default
* @retval LIBINPUT_CONFIG_DRAG_LOCK_ENABLED_TIMEOUT If drag lock is enabled in
* timeout mode by default
* @retval LIBINPUT_CONFIG_DRAG_LOCK_DISABLED If drag lock is disabled by
* default
*
* @see libinput_device_config_tap_set_drag_lock_enabled
* @see libinput_device_config_tap_get_drag_lock_enabled
*/
libinput_device_config_tap_get_default_drag_lock_enabled :: (device: *libinput_device) -> libinput_config_drag_lock_state #foreign libinput_lib;

/**
* @ingroup config
*
* Check if the device can be calibrated via a calibration matrix.
*
* @param device The device to check
* @return Non-zero if the device can be calibrated, zero otherwise.
*
* @see libinput_device_config_calibration_set_matrix
* @see libinput_device_config_calibration_get_matrix
* @see libinput_device_config_calibration_get_default_matrix
*/
libinput_device_config_calibration_has_matrix :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Apply the 3x3 transformation matrix to absolute device coordinates. This
* matrix has no effect on relative events.
*
* Given a 6-element array [a, b, c, d, e, f], the matrix is applied as
* @code
* [ a  b  c ]   [ x ]
* [ d  e  f ] * [ y ]
* [ 0  0  1 ]   [ 1 ]
* @endcode
*
* The translation component (c, f) is expected to be normalized to the
* device coordinate range. For example, the matrix
* @code
* [ 1 0  1 ]
* [ 0 1 -1 ]
* [ 0 0  1 ]
* @endcode
* moves all coordinates by 1 device-width to the right and 1 device-height
* up.
*
* The rotation matrix for rotation around the origin is defined as
* @code
* [ cos(a) -sin(a) 0 ]
* [ sin(a)  cos(a) 0 ]
* [   0      0     1 ]
* @endcode
* Note that any rotation requires an additional translation component to
* translate the rotated coordinates back into the original device space.
* The rotation matrixes for 90, 180 and 270 degrees clockwise are:
* @code
* 90 deg cw:		180 deg cw:		270 deg cw:
* [ 0 -1 1]		[ -1  0 1]		[  0 1 0 ]
* [ 1  0 0]		[  0 -1 1]		[ -1 0 1 ]
* [ 0  0 1]		[  0  0 1]		[  0 0 1 ]
* @endcode
*
* @param device The device to configure
* @param matrix An array representing the first two rows of a 3x3 matrix as
* described above.
*
* @return A config status code.
*
* @see libinput_device_config_calibration_has_matrix
* @see libinput_device_config_calibration_get_matrix
* @see libinput_device_config_calibration_get_default_matrix
*/
libinput_device_config_calibration_set_matrix :: (device: *libinput_device, matrix: *[6] float) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Return the current calibration matrix for this device.
*
* @param device The device to configure
* @param matrix Set to the array representing the first two rows of a 3x3 matrix as
* described in libinput_device_config_calibration_set_matrix().
*
* @return 0 if no calibration is set and the returned matrix is the
* identity matrix, 1 otherwise
*
* @see libinput_device_config_calibration_has_matrix
* @see libinput_device_config_calibration_set_matrix
* @see libinput_device_config_calibration_get_default_matrix
*/
libinput_device_config_calibration_get_matrix :: (device: *libinput_device, matrix: *[6] float) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Return the default calibration matrix for this device. On most devices,
* this is the identity matrix. If the udev property
* <b>LIBINPUT_CALIBRATION_MATRIX</b> is set on the respective udev device,
* that property's value becomes the default matrix, see the libinput
* documentation for more details.
*
* @param device The device to configure
* @param matrix Set to the array representing the first two rows of a 3x3 matrix as
* described in libinput_device_config_calibration_set_matrix().
*
* @return 0 if no calibration is set and the returned matrix is the
* identity matrix, 1 otherwise
*
* @see libinput_device_config_calibration_has_matrix
* @see libinput_device_config_calibration_set_matrix
* @see libinput_device_config_calibration_get_matrix
*/
libinput_device_config_calibration_get_default_matrix :: (device: *libinput_device, matrix: *[6] float) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Describes a rectangle to configure a device's area, see
* libinput_device_config_area_set_rectangle().
*
* This struct describes a rectangle via the upper left points (x1, y1)
* and the lower right point (x2, y2).
*
* All arguments are normalized to the range [0.0, 1.0] to represent the
* corresponding proportion of the device's width and height, respectively.
* A rectangle covering the whole device thus comprises of the points
* (0.0, 0.0) and (1.0, 1.0).
*
* The conditions x1 < x2 and y1 < y2 must be true.
*/
libinput_config_area_rectangle :: struct {
    x1: float64;
    y1: float64;
    x2: float64;
    y2: float64;
}

/**
* @ingroup config
*
* Check if the device can change its logical input area via a rectangle.
*
* @param device The device to check
* @return Non-zero if the device can be calibrated, zero otherwise.
*
* @see libinput_device_config_area_set_rectangle
* @see libinput_device_config_area_get_rectangle
* @see libinput_device_config_area_get_default_rectangle
*/
libinput_device_config_area_has_rectangle :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the given rectangle as the logical input area of this device.
* Future interactions by a tablet tool on this devices are scaled
* to only consider events within this logical input area - as if the
* logical input area were the available physical area.
*
* The coordinates of the rectangle represent the proportion of the
* available maximum physical area, normalized to the range [0.0, 1.0].
* For example, a rectangle with the two points 0.25, 0.5, 0.75, 1.0
* adds a 25% dead zone to the left and right and a 50% dead zone on
* the top:
*
* @code
* +----------------------------------+
* |                                  |
* |                50%               |
* |                                  |
* |        +-----------------+       |
* |        |                 |       |
* |   25%  |                 |  25%  |
* |        |                 |       |
* +--------+-----------------+-------+
* @endcode
*
* The area applies in the tablet's current logical rotation, i.e. the above
* example is always at the bottom of the tablet.
*
* Once applied, the logical area's top-left coordinate (in the current logical
* rotation) becomes the new offset (0/0) and the return values of
* libinput_event_tablet_tool_get_x() and libinput_event_tablet_tool_get_y()
* are in relation to this new offset.
*
* Likewise, libinput_event_tablet_tool_get_x_transformed() and
* libinput_event_tablet_tool_get_y_transformed() represent the value scaled
* into the configured logical area.
*
* The return value of libinput_device_get_size() is not affected by the
* configured area.
*
* Changing the area may not take effect immediately, the device may wait until
* it is in a neutral state before applying any changes.
*
* @param device The device to check
* @param rect The intended rectangle
* @return A config status code. Setting the area on a device that does not
* support area rectangles always fails with @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED.
*
* @see libinput_device_config_area_has_rectangle
* @see libinput_device_config_area_get_rectangle
* @see libinput_device_config_area_get_default_rectangle
*/
libinput_device_config_area_set_rectangle :: (device: *libinput_device, rect: *libinput_config_area_rectangle) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Return the current area rectangle for this device.
*
* The return value for a device that does not support area rectangles is a
* rectangle with the points 0/0  and 1/1.
*
* @note It is an application bug to call this function for devices where
* libinput_device_config_area_has_rectangle() returns 0.
*
* @param device The device to check
* @return The current area rectangle
*
* @see libinput_device_config_area_has_rectangle
* @see libinput_device_config_area_set_rectangle
* @see libinput_device_config_area_get_default_rectangle
*/
libinput_device_config_area_get_rectangle :: (device: *libinput_device) -> libinput_config_area_rectangle #foreign libinput_lib;

/**
* @ingroup config
*
* Return the default area rectangle for this device.
*
* The return value for a device that does not support area rectangles is a
* rectangle with the points 0/0  and 1/1.
*
* @note It is an application bug to call this function for devices where
* libinput_device_config_area_has_rectangle() returns 0.
*
* @param device The device to check
* @return The default area rectangle
*
* @see libinput_device_config_area_has_rectangle
* @see libinput_device_config_area_set_rectangle
* @see libinput_device_config_area_get_rectangle
*/
libinput_device_config_area_get_default_rectangle :: (device: *libinput_device) -> libinput_config_area_rectangle #foreign libinput_lib;

/**
* @ingroup config
*
* The send-event mode of a device defines when a device may generate events
* and pass those events to the caller.
*/
libinput_config_send_events_mode :: enum u32 {
    ENABLED                    :: 0;
    DISABLED                   :: 1;
    DISABLED_ON_EXTERNAL_MOUSE :: 2;

    LIBINPUT_CONFIG_SEND_EVENTS_ENABLED                    :: ENABLED;
    LIBINPUT_CONFIG_SEND_EVENTS_DISABLED                   :: DISABLED;
    LIBINPUT_CONFIG_SEND_EVENTS_DISABLED_ON_EXTERNAL_MOUSE :: DISABLED_ON_EXTERNAL_MOUSE;
}

/**
* @ingroup config
*
* Return the possible send-event modes for this device. These modes define
* when a device may process and send events.
*
* @param device The device to configure
*
* @return A bitmask of possible modes.
*
* @see libinput_device_config_send_events_set_mode
* @see libinput_device_config_send_events_get_mode
* @see libinput_device_config_send_events_get_default_mode
*/
libinput_device_config_send_events_get_modes :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the send-event mode for this device. The mode defines when the device
* processes and sends events to the caller.
*
* The selected mode may not take effect immediately. Events already
* received and processed from this device are unaffected and will be passed
* to the caller on the next call to libinput_get_event().
*
* If the mode is a bitmask of @ref libinput_config_send_events_mode,
* the device may wait for or generate events until it is in a neutral
* state. For example, this may include waiting for or generating button
* release events.
*
* If the device is already suspended, this function does nothing and
* returns success. Changing the send-event mode on a device that has been
* removed is permitted.
*
* @param device The device to configure
* @param mode A bitmask of send-events modes
*
* @return A config status code.
*
* @see libinput_device_config_send_events_get_modes
* @see libinput_device_config_send_events_get_mode
* @see libinput_device_config_send_events_get_default_mode
*/
libinput_device_config_send_events_set_mode :: (device: *libinput_device, mode: u32) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the send-event mode for this device. The mode defines when the device
* processes and sends events to the caller.
*
* If a caller enables the bits for multiple modes, some of which are
* subsets of another mode libinput may drop the bits that are subsets. In
* other words, don't expect libinput_device_config_send_events_get_mode()
* to always return exactly the same bitmask as passed into
* libinput_device_config_send_events_set_mode().
*
* @param device The device to configure
* @return The current bitmask of the send-event mode for this device.
*
* @see libinput_device_config_send_events_get_modes
* @see libinput_device_config_send_events_set_mode
* @see libinput_device_config_send_events_get_default_mode
*/
libinput_device_config_send_events_get_mode :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default send-event mode for this device. The mode defines when
* the device processes and sends events to the caller.
*
* @param device The device to configure
* @return The bitmask of the send-event mode for this device.
*
* @see libinput_device_config_send_events_get_modes
* @see libinput_device_config_send_events_set_mode
* @see libinput_device_config_send_events_get_mode
*/
libinput_device_config_send_events_get_default_mode :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Check if a device uses libinput-internal pointer-acceleration.
*
* @param device The device to configure
*
* @return 0 if the device is not accelerated, nonzero if it is accelerated
*
* @see libinput_device_config_accel_set_speed
* @see libinput_device_config_accel_get_speed
* @see libinput_device_config_accel_get_default_speed
*/
libinput_device_config_accel_is_available :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the pointer acceleration speed of this pointer device within a range
* of [-1, 1], where 0 is the default acceleration for this device, -1 is
* the slowest acceleration and 1 is the maximum acceleration available on
* this device. The actual pointer acceleration mechanism is
* implementation-dependent, as is the number of steps available within the
* range. libinput picks the semantically closest acceleration step if the
* requested value does not match a discrete setting.
*
* @param device The device to configure
* @param speed The normalized speed, in a range of [-1, 1]
*
* @return A config status code
*
* @see libinput_device_config_accel_is_available
* @see libinput_device_config_accel_get_speed
* @see libinput_device_config_accel_get_default_speed
*/
libinput_device_config_accel_set_speed :: (device: *libinput_device, speed: float64) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the current pointer acceleration setting for this pointer device. The
* returned value is normalized to a range of [-1, 1].
* See libinput_device_config_accel_set_speed() for details.
*
* If the current acceleration profile is @ref
* LIBINPUT_CONFIG_ACCEL_PROFILE_CUSTOM, the behavior of the
* device will not change but future calls to
* libinput_device_config_accel_get_speed() will reflect the updated speed
* setting.
*
* @param device The device to configure
*
* @return The current speed, range -1 to 1
*
* @see libinput_device_config_accel_is_available
* @see libinput_device_config_accel_set_speed
* @see libinput_device_config_accel_get_default_speed
*/
libinput_device_config_accel_get_speed :: (device: *libinput_device) -> float64 #foreign libinput_lib;

/**
* @ingroup config
*
* Return the default speed setting for this device, normalized to a range
* of [-1, 1].
* See libinput_device_config_accel_set_speed() for details.
*
* @param device The device to configure
* @return The default speed setting for this device.
*
* @see libinput_device_config_accel_is_available
* @see libinput_device_config_accel_set_speed
* @see libinput_device_config_accel_get_speed
*/
libinput_device_config_accel_get_default_speed :: (device: *libinput_device) -> float64 #foreign libinput_lib;

/**
* @ingroup config
*
* @since 1.1
*/
libinput_config_accel_profile :: enum u32 {
    NONE     :: 0;
    FLAT     :: 1;
    ADAPTIVE :: 2;
    CUSTOM   :: 4;

    LIBINPUT_CONFIG_ACCEL_PROFILE_NONE     :: NONE;
    LIBINPUT_CONFIG_ACCEL_PROFILE_FLAT     :: FLAT;
    LIBINPUT_CONFIG_ACCEL_PROFILE_ADAPTIVE :: ADAPTIVE;
    LIBINPUT_CONFIG_ACCEL_PROFILE_CUSTOM   :: CUSTOM;
}

/**
* @ingroup config
*
* A handle for configuration pointer acceleration.
*
* @warning Unlike other structs pointer acceleration configuration is
* considered transient and <b>not</b> refcounted. Calling
* libinput_config_accel_destroy() <b>will</b> destroy the configuration.
*
* To configure pointer acceleration, first create a config of a desired
* acceleration profile with libinput_config_accel_create(), then
* configure the profile-specific acceleration properties.
*
* In this version of libinput, this pointer acceleration configuration
* only provides configuration for @ref LIBINPUT_CONFIG_ACCEL_PROFILE_CUSTOM.
*
* For @ref LIBINPUT_CONFIG_ACCEL_PROFILE_CUSTOM use
* @ref libinput_config_accel_set_points.
*
* Once set up, apply the configuration to a device using
* libinput_device_config_accel_apply(). Once applied,
* destroy it with libinput_config_accel_destroy().
*
* @since 1.23
*/
libinput_config_accel :: struct {}

/**
* @ingroup config
*
* Create an acceleration configuration of a given profile.
*
* Note that in this version of libinput, only the
* @ref LIBINPUT_CONFIG_ACCEL_PROFILE_CUSTOM profile provides configuration
* options. All other acceleration profiles, when applied, will merely switch
* the profile and reset any profile-specific options to the default values.
*
* @param profile The profile of the newly created acceleration configuration.
*
* @return The newly created acceleration configuration or NULL on error.
*
* @warning Unlike other structs pointer acceleration configuration is
* considered transient and <b>not</b> refcounted. Calling
* libinput_config_accel_destroy() <b>will</b> destroy the configuration.
*
* @see libinput_config_accel
* @since 1.23
*/
libinput_config_accel_create :: (profile: libinput_config_accel_profile) -> *libinput_config_accel #foreign libinput_lib;

/**
* @ingroup config
*
* Destroy an acceleration configuration.
*
* @warning Unlike other structs pointer acceleration configuration is
* considered transient and <b>not</b> refcounted. Calling
* libinput_config_accel_destroy() <b>will</b> destroy the configuration.
*
* @param accel_config The acceleration configuration to destroy.
*
* @see libinput_config_accel
* @since 1.23
*/
libinput_config_accel_destroy :: (accel_config: *libinput_config_accel) -> void #foreign libinput_lib;

/**
* @ingroup config
*
* Apply this pointer acceleration configuration to the device. This changes the
* device's pointer acceleration method to the method given in
* libinput_config_accel_create() and applies all other configuration settings.
*
* Once applied, call libinput_config_accel_destroy() to destroy the
* configuration struct.
*
* @param device The device to configure.
* @param accel_config The acceleration configuration.
*
* @return A config status code.
*
* @see libinput_config_accel
* @since 1.23
*/
libinput_device_config_accel_apply :: (device: *libinput_device, accel_config: *libinput_config_accel) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Acceleration types are categories of movement by a device that may have
* specific acceleration functions applied. A device always supports the
* @ref LIBINPUT_ACCEL_TYPE_MOTION type (for regular pointer motion). Other
* types (e.g. scrolling) may be added in the future.
*
* The special type @ref LIBINPUT_ACCEL_TYPE_FALLBACK specifies the acceleration
* function to be moved for any movement produced by the device that does not
* have a specific acceleration type defined.
*
* Use to specify the acceleration function type in
* @ref libinput_config_accel_set_points
*
* Each device implements a subset of those types, see a list of supported
* devices for each movement type definition.
*
* @see LIBINPUT_ACCEL_ARG_TYPE
* @since 1.23
*/
libinput_config_accel_type :: enum u32 {
    FALLBACK :: 0;
    MOTION   :: 1;
    SCROLL   :: 2;

    LIBINPUT_ACCEL_TYPE_FALLBACK :: FALLBACK;
    LIBINPUT_ACCEL_TYPE_MOTION   :: MOTION;
    LIBINPUT_ACCEL_TYPE_SCROLL   :: SCROLL;
}

/**
* @ingroup config
*
* Defines the acceleration function for a given movement type
* in an acceleration configuration with the profile
* @ref LIBINPUT_CONFIG_ACCEL_PROFILE_CUSTOM.
*
* Movement types are specific to each device, @see libinput_config_accel_type.
*
* Each custom acceleration function is defined by ``n`` points spaced uniformly
* along the x-axis starting from 0 and continuing in a constant step size.
* There by the function is defined by the following points:
* (0 * step, f[0]), (1 * step, f[1]), ..., ((n - 1) * step, f[n - 1]).
* The x-axis represents the device-speed in device units per millisecond.
* The y-axis represents the pointer-speed.
*
* It is up to the user to define those values in accordance with device DPI
* and screen DPI.
*
* @param accel_config The acceleration configuration to modify.
* @param accel_type The movement type to configure a custom function for.
* @param step The distance between each point along the x-axis.
* @param npoints The number of points of the custom acceleration function.
* @param points The points' y-values of the custom acceleration function.
*
* @return A config status code.
*
* @see libinput_config_accel
* @since 1.23
*/
libinput_config_accel_set_points :: (accel_config: *libinput_config_accel, accel_type: libinput_config_accel_type, step: float64, npoints: u64, points: *float64) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Returns a bitmask of the configurable acceleration modes available on
* this device.
*
* @param device The device to configure
*
* @return A bitmask of all configurable modes available on this device.
*
* @since 1.1
*/
libinput_device_config_accel_get_profiles :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the pointer acceleration profile of this pointer device to the given
* mode.
*
* @param device The device to configure
* @param profile The profile to set the device to.
*
* @return A config status code
*
* @since 1.1
*/
libinput_device_config_accel_set_profile :: (device: *libinput_device, profile: libinput_config_accel_profile) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the current pointer acceleration profile for this pointer device.
*
* @param device The device to configure
*
* @return The currently configured pointer acceleration profile.
*
* @since 1.1
*/
libinput_device_config_accel_get_profile :: (device: *libinput_device) -> libinput_config_accel_profile #foreign libinput_lib;

/**
* @ingroup config
*
* Return the default pointer acceleration profile for this pointer device.
*
* @param device The device to configure
*
* @return The default acceleration profile for this device.
*
* @since 1.1
*/
libinput_device_config_accel_get_default_profile :: (device: *libinput_device) -> libinput_config_accel_profile #foreign libinput_lib;

/**
* @ingroup config
*
* Return non-zero if the device supports "natural scrolling".
*
* In traditional scroll mode, the movement of fingers on a touchpad when
* scrolling matches the movement of the scroll bars. When the fingers move
* down, the scroll bar moves down, a line of text on the screen moves
* towards the upper end of the screen. This also matches scroll wheels on
* mice (wheel down, content moves up).
*
* Natural scrolling is the term coined by Apple for inverted scrolling.
* In this mode, the effect of scrolling movement of fingers on a touchpad
* resemble physical manipulation of paper. When the fingers move down, a
* line of text on the screen moves down (scrollbars move up). This is the
* opposite of scroll wheels on mice.
*
* A device supporting natural scrolling can be switched between traditional
* scroll mode and natural scroll mode.
*
* @param device The device to configure
*
* @return Zero if natural scrolling is not supported, non-zero if natural
* scrolling is supported by this device
*
* @see libinput_device_config_scroll_set_natural_scroll_enabled
* @see libinput_device_config_scroll_get_natural_scroll_enabled
* @see libinput_device_config_scroll_get_default_natural_scroll_enabled
*/
libinput_device_config_scroll_has_natural_scroll :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Enable or disable natural scrolling on the device.
*
* @param device The device to configure
* @param enable non-zero to enable, zero to disable natural scrolling
*
* @return A config status code
*
* @see libinput_device_config_scroll_has_natural_scroll
* @see libinput_device_config_scroll_get_natural_scroll_enabled
* @see libinput_device_config_scroll_get_default_natural_scroll_enabled
*/
libinput_device_config_scroll_set_natural_scroll_enabled :: (device: *libinput_device, enable: s32) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the current mode for scrolling on this device
*
* @param device The device to configure
*
* @return Zero if natural scrolling is disabled, non-zero if enabled
*
* @see libinput_device_config_scroll_has_natural_scroll
* @see libinput_device_config_scroll_set_natural_scroll_enabled
* @see libinput_device_config_scroll_get_default_natural_scroll_enabled
*/
libinput_device_config_scroll_get_natural_scroll_enabled :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default mode for scrolling on this device
*
* @param device The device to configure
*
* @return Zero if natural scrolling is disabled by default, non-zero if enabled
*
* @see libinput_device_config_scroll_has_natural_scroll
* @see libinput_device_config_scroll_set_natural_scroll_enabled
* @see libinput_device_config_scroll_get_natural_scroll_enabled
*/
libinput_device_config_scroll_get_default_natural_scroll_enabled :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Check if a device has a configuration that supports left-handed usage.
*
* @param device The device to configure
* @return Non-zero if the device can be set to left-handed, or zero
* otherwise
*
* @see libinput_device_config_left_handed_set
* @see libinput_device_config_left_handed_get
* @see libinput_device_config_left_handed_get_default
*/
libinput_device_config_left_handed_is_available :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the left-handed configuration of the device.
*
* The exact behavior is device-dependent. On a mouse and most pointing
* devices, left and right buttons are swapped but the middle button is
* unmodified. On a touchpad, physical buttons (if present) are swapped. On a
* clickpad, the top and bottom software-emulated buttons are swapped where
* present, the main area of the touchpad remains a left button. Tapping and
* clickfinger behavior is not affected by this setting.
*
* Changing the left-handed configuration of a device may not take effect
* until all buttons have been logically released.
*
* @param device The device to configure
* @param left_handed Zero to disable, non-zero to enable left-handed mode
* @return A configuration status code
*
* @see libinput_device_config_left_handed_is_available
* @see libinput_device_config_left_handed_get
* @see libinput_device_config_left_handed_get_default
*/
libinput_device_config_left_handed_set :: (device: *libinput_device, left_handed: s32) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the current left-handed configuration of the device.
*
* @param device The device to configure
* @return Zero if the device is in right-handed mode, non-zero if the
* device is in left-handed mode
*
* @see libinput_device_config_left_handed_is_available
* @see libinput_device_config_left_handed_set
* @see libinput_device_config_left_handed_get_default
*/
libinput_device_config_left_handed_get :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default left-handed configuration of the device.
*
* @param device The device to configure
* @return Zero if the device is in right-handed mode by default, or non-zero
* if the device is in left-handed mode by default
*
* @see libinput_device_config_left_handed_is_available
* @see libinput_device_config_left_handed_set
* @see libinput_device_config_left_handed_get
*/
libinput_device_config_left_handed_get_default :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* The click method defines when to generate software-emulated
* buttons, usually on a device that does not have a specific physical
* button available.
*/
libinput_config_click_method :: enum u32 {
    NONE         :: 0;
    BUTTON_AREAS :: 1;
    CLICKFINGER  :: 2;

    LIBINPUT_CONFIG_CLICK_METHOD_NONE         :: NONE;
    LIBINPUT_CONFIG_CLICK_METHOD_BUTTON_AREAS :: BUTTON_AREAS;
    LIBINPUT_CONFIG_CLICK_METHOD_CLICKFINGER  :: CLICKFINGER;
}

/**
* @ingroup config
*
* Check which button click methods a device supports. The button click
* method defines when to generate software-emulated buttons, usually on a
* device that does not have a specific physical button available.
*
* @param device The device to configure
*
* @return A bitmask of possible methods.
*
* @see libinput_device_config_click_get_methods
* @see libinput_device_config_click_set_method
* @see libinput_device_config_click_get_method
*/
libinput_device_config_click_get_methods :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the button click method for this device. The button click
* method defines when to generate software-emulated buttons, usually on a
* device that does not have a specific physical button available.
*
* @note The selected click method may not take effect immediately. The
* device may require changing to a neutral state first before activating
* the new method.
*
* @param device The device to configure
* @param method The button click method
*
* @return A config status code
*
* @see libinput_device_config_click_get_methods
* @see libinput_device_config_click_get_method
* @see libinput_device_config_click_get_default_method
*/
libinput_device_config_click_set_method :: (device: *libinput_device, method: libinput_config_click_method) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the button click method for this device. The button click
* method defines when to generate software-emulated buttons, usually on a
* device that does not have a specific physical button available.
*
* @param device The device to configure
*
* @return The current button click method for this device
*
* @see libinput_device_config_click_get_methods
* @see libinput_device_config_click_set_method
* @see libinput_device_config_click_get_default_method
*/
libinput_device_config_click_get_method :: (device: *libinput_device) -> libinput_config_click_method #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default button click method for this device. The button click
* method defines when to generate software-emulated buttons, usually on a
* device that does not have a specific physical button available.
*
* @param device The device to configure
*
* @return The default button click method for this device
*
* @see libinput_device_config_click_get_methods
* @see libinput_device_config_click_set_method
* @see libinput_device_config_click_get_method
*/
libinput_device_config_click_get_default_method :: (device: *libinput_device) -> libinput_config_click_method #foreign libinput_lib;

/**
* @ingroup config
*
* Set the finger number to button number mapping for clickfinger. The
* default mapping on most devices is to have a 1, 2 and 3 finger tap to map
* to the left, right and middle button, respectively.
* A device may permit changing the button mapping but disallow specific
* maps. In this case @ref LIBINPUT_CONFIG_STATUS_UNSUPPORTED is returned,
* the caller is expected to handle this case correctly.
*
* Changing the button mapping may not take effect immediately,
* the device may wait until it is in a neutral state before applying any
* changes.
*
* @param device The device to configure
* @param map The new finger-to-button number mapping
*
* @return A config status code. Changing the order on a device that does not
* support the clickfinger method always fails with @ref
* LIBINPUT_CONFIG_STATUS_UNSUPPORTED.
*
* @see libinput_device_config_click_get_clickfinger_button_map
* @see libinput_device_config_click_get_default_clickfinger_button_map
*/
libinput_device_config_click_set_clickfinger_button_map :: (device: *libinput_device, map: libinput_config_clickfinger_button_map) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the finger number to button number mapping for clickfinger.
*
* The return value for a device that does not support clickfinger is always
* @ref LIBINPUT_CONFIG_CLICKFINGER_MAP_LRM.
*
* @param device The device to configure
* @return The current finger-to-button number mapping
*
* @see libinput_device_config_click_set_clickfinger_button_map
* @see libinput_device_config_click_get_default_clickfinger_button_map
*/
libinput_device_config_click_get_clickfinger_button_map :: (device: *libinput_device) -> libinput_config_clickfinger_button_map #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default finger number to button number mapping for clickfinger.
*
* The return value for a device that does not support clickfinger is always
* @ref LIBINPUT_CONFIG_CLICKFINGER_MAP_LRM.
*
* @param device The device to configure
* @return The default finger-to-button number mapping
*
* @see libinput_device_config_click_set_clickfinger_button_map
* @see libinput_device_config_click_get_clickfinger_button_map
*/
libinput_device_config_click_get_default_clickfinger_button_map :: (device: *libinput_device) -> libinput_config_clickfinger_button_map #foreign libinput_lib;

/**
* @ingroup config
*/
libinput_config_middle_emulation_state :: enum u32 {
    DISABLED :: 0;
    ENABLED  :: 1;

    LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED :: DISABLED;
    LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED  :: ENABLED;
}

/**
* @ingroup config
*
* Check if middle mouse button emulation configuration is available on this
* device. See libinput_device_config_middle_emulation_set_enabled() for
* more details.
*
* @note Some devices provide middle mouse button emulation but do not allow
* enabling/disabling that emulation. These devices return zero in
* libinput_device_config_middle_emulation_is_available().
*
* @param device The device to query
*
* @return Non-zero if middle mouse button emulation is available and can be
* configured, zero otherwise.
*
* @see libinput_device_config_middle_emulation_set_enabled
* @see libinput_device_config_middle_emulation_get_enabled
* @see libinput_device_config_middle_emulation_get_default_enabled
*/
libinput_device_config_middle_emulation_is_available :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Enable or disable middle button emulation on this device. When enabled, a
* simultaneous press of the left and right button generates a middle mouse
* button event. Releasing the buttons generates a middle mouse button
* release, the left and right button events are discarded otherwise.
*
* See the libinput documentation for more details.
*
* @param device The device to configure
* @param enable @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED to
* disable, @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED To enable
* middle button emulation.
*
* @return A config status code. Disabling middle button emulation on a
* device that does not support middle button emulation always succeeds.
*
* @see libinput_device_config_middle_emulation_is_available
* @see libinput_device_config_middle_emulation_get_enabled
* @see libinput_device_config_middle_emulation_get_default_enabled
*/
libinput_device_config_middle_emulation_set_enabled :: (device: *libinput_device, enable: libinput_config_middle_emulation_state) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Check if configurable middle button emulation is enabled on this device.
* See libinput_device_config_middle_emulation_set_enabled() for more
* details.
*
* If the device does not have configurable middle button emulation, this
* function returns @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
*
* @note Some devices provide middle mouse button emulation but do not allow
* enabling/disabling that emulation. These devices always return @ref
* LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
*
* @param device The device to configure
* @return @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED if disabled
* or not available/configurable, @ref
* LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED If enabled.
*
* @see libinput_device_config_middle_emulation_is_available
* @see libinput_device_config_middle_emulation_set_enabled
* @see libinput_device_config_middle_emulation_get_default_enabled
*/
libinput_device_config_middle_emulation_get_enabled :: (device: *libinput_device) -> libinput_config_middle_emulation_state #foreign libinput_lib;

/**
* @ingroup config
*
* Check if configurable middle button emulation is enabled by default on
* this device. See libinput_device_config_middle_emulation_set_enabled()
* for more details.
*
* If the device does not have configurable middle button
* emulation, this function returns @ref
* LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
*
* @note Some devices provide middle mouse button emulation but do not allow
* enabling/disabling that emulation. These devices always return @ref
* LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED.
*
* @param device The device to configure
* @return @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED If disabled
* or not available, @ref LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED if
* enabled.
*
* @see libinput_device_config_middle_emulation_is_available
* @see libinput_device_config_middle_emulation_set_enabled
* @see libinput_device_config_middle_emulation_get_enabled
*/
libinput_device_config_middle_emulation_get_default_enabled :: (device: *libinput_device) -> libinput_config_middle_emulation_state #foreign libinput_lib;

/**
* @ingroup config
*
* The scroll method of a device selects when to generate scroll axis events
* instead of pointer motion events.
*/
libinput_config_scroll_method :: enum u32 {
    NO_SCROLL      :: 0;
    _2FG           :: 1;
    EDGE           :: 2;
    ON_BUTTON_DOWN :: 4;

    LIBINPUT_CONFIG_SCROLL_NO_SCROLL      :: NO_SCROLL;
    LIBINPUT_CONFIG_SCROLL_2FG            :: _2FG;
    LIBINPUT_CONFIG_SCROLL_EDGE           :: EDGE;
    LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN :: ON_BUTTON_DOWN;
}

/**
* @ingroup config
*
* Check which scroll methods a device supports. The method defines when to
* generate scroll axis events instead of pointer motion events.
*
* @param device The device to configure
*
* @return A bitmask of possible methods.
*
* @see libinput_device_config_scroll_set_method
* @see libinput_device_config_scroll_get_method
* @see libinput_device_config_scroll_get_default_method
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_get_button
* @see libinput_device_config_scroll_get_default_button
*/
libinput_device_config_scroll_get_methods :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the scroll method for this device. The method defines when to
* generate scroll axis events instead of pointer motion events.
*
* @note Setting @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN enables
* the scroll method, but scrolling is only activated when the configured
* button is held down. If no button is set, i.e.
* libinput_device_config_scroll_get_button() returns 0, scrolling
* cannot activate.
*
* @param device The device to configure
* @param method The scroll method for this device.
*
* @return A config status code.
*
* @see libinput_device_config_scroll_get_methods
* @see libinput_device_config_scroll_get_method
* @see libinput_device_config_scroll_get_default_method
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_get_button
* @see libinput_device_config_scroll_get_default_button
*/
libinput_device_config_scroll_set_method :: (device: *libinput_device, method: libinput_config_scroll_method) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the scroll method for this device. The method defines when to
* generate scroll axis events instead of pointer motion events.
*
* @param device The device to configure
* @return The current scroll method for this device.
*
* @see libinput_device_config_scroll_get_methods
* @see libinput_device_config_scroll_set_method
* @see libinput_device_config_scroll_get_default_method
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_get_button
* @see libinput_device_config_scroll_get_default_button
*/
libinput_device_config_scroll_get_method :: (device: *libinput_device) -> libinput_config_scroll_method #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default scroll method for this device. The method defines when to
* generate scroll axis events instead of pointer motion events.
*
* @param device The device to configure
* @return The default scroll method for this device.
*
* @see libinput_device_config_scroll_get_methods
* @see libinput_device_config_scroll_set_method
* @see libinput_device_config_scroll_get_method
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_get_button
* @see libinput_device_config_scroll_get_default_button
*/
libinput_device_config_scroll_get_default_method :: (device: *libinput_device) -> libinput_config_scroll_method #foreign libinput_lib;

/**
* @ingroup config
*
* Set the button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
* for this device.
*
* When the current scroll method is set to @ref
* LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN, no button press/release events
* will be send for the configured button.
*
* When the configured button is pressed, any motion events along a
* scroll-capable axis are turned into scroll axis events.
*
* @note Setting the button does not change the scroll method. To change the
* scroll method call libinput_device_config_scroll_set_method().
*
* If the button is 0, button scrolling is effectively disabled.
*
* @param device The device to configure
* @param button The button which when pressed switches to sending scroll events
*
* @return A config status code
* @retval LIBINPUT_CONFIG_STATUS_SUCCESS On success
* @retval LIBINPUT_CONFIG_STATUS_UNSUPPORTED If @ref
* LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN is not supported
* @retval LIBINPUT_CONFIG_STATUS_INVALID The given button does not
* exist on this device
*
* @see libinput_device_config_scroll_get_methods
* @see libinput_device_config_scroll_set_method
* @see libinput_device_config_scroll_get_method
* @see libinput_device_config_scroll_get_default_method
* @see libinput_device_config_scroll_get_button
* @see libinput_device_config_scroll_get_default_button
*/
libinput_device_config_scroll_set_button :: (device: *libinput_device, button: u32) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
* for this device.
*
* If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not
* supported, or no button is set, this function returns 0.
*
* @note The return value is independent of the currently selected
* scroll-method. For button scrolling to activate, a device must have the
* @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method enabled, and a non-zero
* button set as scroll button.
*
* @param device The device to configure
* @return The button which when pressed switches to sending scroll events
*
* @see libinput_device_config_scroll_get_methods
* @see libinput_device_config_scroll_set_method
* @see libinput_device_config_scroll_get_method
* @see libinput_device_config_scroll_get_default_method
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_get_default_button
*/
libinput_device_config_scroll_get_button :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default button for the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN
* method for this device.
*
* If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not supported,
* or no default button is set, this function returns 0.
*
* @param device The device to configure
* @return The default button for the @ref
* LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method
*
* @see libinput_device_config_scroll_get_methods
* @see libinput_device_config_scroll_set_method
* @see libinput_device_config_scroll_get_method
* @see libinput_device_config_scroll_get_default_method
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_get_button
*/
libinput_device_config_scroll_get_default_button :: (device: *libinput_device) -> u32 #foreign libinput_lib;

libinput_config_scroll_button_lock_state :: enum u32 {
    DISABLED :: 0;
    ENABLED  :: 1;

    LIBINPUT_CONFIG_SCROLL_BUTTON_LOCK_DISABLED :: DISABLED;
    LIBINPUT_CONFIG_SCROLL_BUTTON_LOCK_ENABLED  :: ENABLED;
}

/**
* @ingroup config
*
* Set the scroll button lock. If the state is
* @ref LIBINPUT_CONFIG_SCROLL_BUTTON_LOCK_DISABLED, the button must
* physically be held down for button scrolling to work.
* If the state is
* @ref LIBINPUT_CONFIG_SCROLL_BUTTON_LOCK_ENABLED, the button is considered
* logically down after the first press and release sequence, and logically
* up after the second press and release sequence.
*
* @param device The device to configure
* @param state The state to set the scroll button lock to
*
* @return A config status code. Disabling the scroll button lock on
* device that does not support button scrolling always succeeds.
*
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_get_button
* @see libinput_device_config_scroll_get_default_button
*/
libinput_device_config_scroll_set_button_lock :: (device: *libinput_device, state: libinput_config_scroll_button_lock_state) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the current scroll button lock state.
*
* If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not
* supported, or no button is set, this function returns @ref
* LIBINPUT_CONFIG_SCROLL_BUTTON_LOCK_DISABLED.
*
* @note The return value is independent of the currently selected
* scroll-method. For the scroll button lock to activate, a device must have
* the @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN method enabled, and a
* non-zero button set as scroll button.
*
* @param device The device to configure
* @return The scroll button lock state
*
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_set_button_lock
* @see libinput_device_config_scroll_get_button_lock
* @see libinput_device_config_scroll_get_default_button_lock
*/
libinput_device_config_scroll_get_button_lock :: (device: *libinput_device) -> libinput_config_scroll_button_lock_state #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default scroll button lock state.
*
* If @ref LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN scroll method is not
* supported, or no button is set, this function returns @ref
* LIBINPUT_CONFIG_SCROLL_BUTTON_LOCK_DISABLED.
*
* @param device The device to configure
* @return The default scroll button lock state
*
* @see libinput_device_config_scroll_set_button
* @see libinput_device_config_scroll_set_button_lock
* @see libinput_device_config_scroll_get_button_lock
* @see libinput_device_config_scroll_get_default_button_lock
*/
libinput_device_config_scroll_get_default_button_lock :: (device: *libinput_device) -> libinput_config_scroll_button_lock_state #foreign libinput_lib;

/**
* @ingroup config
*
* Possible states for the disable-while-typing feature.
*/
libinput_config_dwt_state :: enum u32 {
    DISABLED :: 0;
    ENABLED  :: 1;

    LIBINPUT_CONFIG_DWT_DISABLED :: DISABLED;
    LIBINPUT_CONFIG_DWT_ENABLED  :: ENABLED;
}

/**
* @ingroup config
*
* Check if this device supports configurable disable-while-typing feature.
* This feature is usually available on built-in touchpads and disables the
* touchpad while typing. See the libinput documentation for details.
*
* @param device The device to configure
* @return 0 if this device does not support disable-while-typing, or 1
* otherwise.
*
* @see libinput_device_config_dwt_set_enabled
* @see libinput_device_config_dwt_get_enabled
* @see libinput_device_config_dwt_get_default_enabled
*/
libinput_device_config_dwt_is_available :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Enable or disable the disable-while-typing feature. When enabled, the
* device will be disabled while typing and for a short period after. See
* the libinput documentation for details.
*
* @note Enabling or disabling disable-while-typing may not take effect
* immediately.
*
* @param device The device to configure
* @param enable @ref LIBINPUT_CONFIG_DWT_DISABLED to disable
* disable-while-typing, @ref LIBINPUT_CONFIG_DWT_ENABLED to enable
*
* @return A config status code. Disabling disable-while-typing on a
* device that does not support the feature always succeeds.
*
* @see libinput_device_config_dwt_is_available
* @see libinput_device_config_dwt_get_enabled
* @see libinput_device_config_dwt_get_default_enabled
*/
libinput_device_config_dwt_set_enabled :: (device: *libinput_device, enable: libinput_config_dwt_state) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Check if the disable-while typing feature is currently enabled on this
* device. If the device does not support disable-while-typing, this
* function returns @ref LIBINPUT_CONFIG_DWT_DISABLED.
*
* @param device The device to configure
* @return @ref LIBINPUT_CONFIG_DWT_DISABLED if disabled, @ref
* LIBINPUT_CONFIG_DWT_ENABLED if enabled.
*
* @see libinput_device_config_dwt_is_available
* @see libinput_device_config_dwt_set_enabled
* @see libinput_device_config_dwt_get_default_enabled
*/
libinput_device_config_dwt_get_enabled :: (device: *libinput_device) -> libinput_config_dwt_state #foreign libinput_lib;

/**
* @ingroup config
*
* Check if the disable-while typing feature is enabled on this device by
* default. If the device does not support disable-while-typing, this
* function returns @ref LIBINPUT_CONFIG_DWT_DISABLED.
*
* @param device The device to configure
* @return @ref LIBINPUT_CONFIG_DWT_DISABLED if disabled, @ref
* LIBINPUT_CONFIG_DWT_ENABLED if enabled.
*
* @see libinput_device_config_dwt_is_available
* @see libinput_device_config_dwt_set_enabled
* @see libinput_device_config_dwt_get_enabled
*/
libinput_device_config_dwt_get_default_enabled :: (device: *libinput_device) -> libinput_config_dwt_state #foreign libinput_lib;

/**
* @ingroup config
*
* Possible states for the disable-while-trackpointing feature.
*
* @since 1.21
*/
libinput_config_dwtp_state :: enum u32 {
    DISABLED :: 0;
    ENABLED  :: 1;

    LIBINPUT_CONFIG_DWTP_DISABLED :: DISABLED;
    LIBINPUT_CONFIG_DWTP_ENABLED  :: ENABLED;
}

/**
* @ingroup config
*
* Check if this device supports configurable disable-while-trackpointing
* feature. This feature is usually available on Thinkpads and disables the
* touchpad while using the trackpoint. See the libinput documentation for
* details.
*
* @param device The device to configure
* @return 0 if this device does not support disable-while-trackpointing, or 1
* otherwise.
*
* @see libinput_device_config_dwtp_set_enabled
* @see libinput_device_config_dwtp_get_enabled
* @see libinput_device_config_dwtp_get_default_enabled
*
* @since 1.21
*/
libinput_device_config_dwtp_is_available :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Enable or disable the disable-while-trackpointing feature. When enabled, the
* device will be disabled while using the trackpoint and for a short period
* after. See the libinput documentation for details.
*
* @note Enabling or disabling disable-while-trackpointing may not take effect
* immediately.
*
* @param device The device to configure
* @param enable @ref LIBINPUT_CONFIG_DWTP_DISABLED to disable
* disable-while-trackpointing, @ref LIBINPUT_CONFIG_DWTP_ENABLED to enable
*
* @return A config status code. Disabling disable-while-trackpointing on a
* device that does not support the feature always succeeds.
*
* @see libinput_device_config_dwtp_is_available
* @see libinput_device_config_dwtp_get_enabled
* @see libinput_device_config_dwtp_get_default_enabled
*
* @since 1.21
*/
libinput_device_config_dwtp_set_enabled :: (device: *libinput_device, enable: libinput_config_dwtp_state) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Check if the disable-while trackpointing feature is currently enabled on
* this device. If the device does not support disable-while-trackpointing,
* this function returns @ref LIBINPUT_CONFIG_DWTP_DISABLED.
*
* @param device The device to configure
* @return @ref LIBINPUT_CONFIG_DWTP_DISABLED if disabled, @ref
* LIBINPUT_CONFIG_DWTP_ENABLED if enabled.
*
* @see libinput_device_config_dwtp_is_available
* @see libinput_device_config_dwtp_set_enabled
* @see libinput_device_config_dwtp_get_default_enabled
*
* @since 1.21
*/
libinput_device_config_dwtp_get_enabled :: (device: *libinput_device) -> libinput_config_dwtp_state #foreign libinput_lib;

/**
* @ingroup config
*
* Check if the disable-while trackpointing feature is enabled on this device
* by default. If the device does not support disable-while-trackpointing, this
* function returns @ref LIBINPUT_CONFIG_DWTP_DISABLED.
*
* @param device The device to configure
* @return @ref LIBINPUT_CONFIG_DWTP_DISABLED if disabled, @ref
* LIBINPUT_CONFIG_DWTP_ENABLED if enabled.
*
* @see libinput_device_config_dwtp_is_available
* @see libinput_device_config_dwtp_set_enabled
* @see libinput_device_config_dwtp_get_enabled
*
* @since 1.21
*/
libinput_device_config_dwtp_get_default_enabled :: (device: *libinput_device) -> libinput_config_dwtp_state #foreign libinput_lib;

/**
* @ingroup config
*
* Check whether a device can have a custom rotation applied.
*
* @param device The device to configure
* @return Non-zero if a device can be rotated, zero otherwise.
*
* @see libinput_device_config_rotation_set_angle
* @see libinput_device_config_rotation_get_angle
* @see libinput_device_config_rotation_get_default_angle
*
* @since 1.4
*/
libinput_device_config_rotation_is_available :: (device: *libinput_device) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the rotation of a device in degrees clockwise off the logical neutral
* position. Any subsequent motion events are adjusted according to the
* given angle.
*
* The angle has to be in the range of [0, 360[ degrees, otherwise this
* function returns LIBINPUT_CONFIG_STATUS_INVALID. If the angle is a
* multiple of 360 or negative, the caller must ensure the correct ranging
* before calling this function.
*
* The rotation angle is applied to all motion events emitted by the device.
* Thus, rotating the device also changes the angle required or presented by
* scrolling, gestures, etc.
*
* @param device The device to configure
* @param degrees_cw The angle in degrees clockwise
* @return A config status code. Setting a rotation of 0 degrees on a
* device that does not support rotation always succeeds.
*
* @see libinput_device_config_rotation_is_available
* @see libinput_device_config_rotation_get_angle
* @see libinput_device_config_rotation_get_default_angle
*
* @since 1.4
*/
libinput_device_config_rotation_set_angle :: (device: *libinput_device, degrees_cw: u32) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the current rotation of a device in degrees clockwise off the logical
* neutral position. If this device does not support rotation, the return
* value is always 0.
*
* @param device The device to configure
* @return The angle in degrees clockwise
*
* @see libinput_device_config_rotation_is_available
* @see libinput_device_config_rotation_set_angle
* @see libinput_device_config_rotation_get_default_angle
*
* @since 1.4
*/
libinput_device_config_rotation_get_angle :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the default rotation of a device in degrees clockwise off the logical
* neutral position. If this device does not support rotation, the return
* value is always 0.
*
* @param device The device to configure
* @return The default angle in degrees clockwise
*
* @see libinput_device_config_rotation_is_available
* @see libinput_device_config_rotation_set_angle
* @see libinput_device_config_rotation_get_angle
*
* @since 1.4
*/
libinput_device_config_rotation_get_default_angle :: (device: *libinput_device) -> u32 #foreign libinput_lib;

/**
* @ingroup config
*
* Check if a tablet tool can have a custom pressure range.
*
* @param tool The libinput tool
* @return Non-zero if a device has an adjustible pressure range, zero otherwise.
*
* @see libinput_tablet_tool_config_pressure_range_set
* @see libinput_tablet_tool_config_pressure_range_get_minimum
* @see libinput_tablet_tool_config_pressure_range_get_maximum
* @see libinput_tablet_tool_config_pressure_range_get_default_minimum
* @see libinput_tablet_tool_config_pressure_range_get_default_maximum
*
* @since 1.26
*/
libinput_tablet_tool_config_pressure_range_is_available :: (tool: *libinput_tablet_tool) -> s32 #foreign libinput_lib;

/**
* @ingroup config
*
* Set the pressure range for this tablet tool. This maps the given logical
* pressure range into the available hardware pressure range so that a hardware
* pressure of the given minimum value maps into a logical pressure of 0.0 (as
* returned by libinput_event_tablet_tool_get_pressure()) and the hardware
* pressure of the given maximum value is mapped into the logical pressure
* of 1.0 (as returned by libinput_event_tablet_tool_get_pressure())
*
* The minimum value must be less than the maximum value, libinput may
* require the values to have a specific distance to each other,
* i.e. that (maximum - minimum > N) for an implementation-defined value of N.
*
* @param tool The libinput tool
* @param minimum The minimum pressure value in the range [0.0, 1.0)
* @param maximum The maximum pressure value in the range (0.0, 1.0]
*
* @return A config status code
*
* @see libinput_tablet_tool_config_pressure_range_is_available
* @see libinput_tablet_tool_config_pressure_range_get_minimum
* @see libinput_tablet_tool_config_pressure_range_get_maximum
* @see libinput_tablet_tool_config_pressure_range_get_default_minimum
* @see libinput_tablet_tool_config_pressure_range_get_default_maximum
*
* @since 1.26
*/
libinput_tablet_tool_config_pressure_range_set :: (tool: *libinput_tablet_tool, minimum: float64, maximum: float64) -> libinput_config_status #foreign libinput_lib;

/**
* @ingroup config
*
* Get the minimum pressure value for this tablet tool, normalized to the
* range [0.0, 1.0] of the available hardware pressure.
*
* If the tool does not support pressure range configuration, the return value
* of this function is always 0.0.
*
* @param tool The libinput tool
* @return The minimum pressure value for this tablet tool
*
* @see libinput_tablet_tool_config_pressure_range_is_available
* @see libinput_tablet_tool_config_pressure_range_get_maximum
* @see libinput_tablet_tool_config_pressure_range_get_default_minimum
* @see libinput_tablet_tool_config_pressure_range_get_default_maximum
*
* @since 1.26
*/
libinput_tablet_tool_config_pressure_range_get_minimum :: (tool: *libinput_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the maximum pressure value for this tablet tool, normalized to the
* range [0.0, 1.0] of the available hardware pressure.
*
* If the tool does not support pressure range configuration, the return value
* of this function is always 1.0.
*
* @param tool The libinput tool
* @return The maximum pressure value for this tablet tool
*
* @see libinput_tablet_tool_config_pressure_range_is_available
* @see libinput_tablet_tool_config_pressure_range_get_minimum
* @see libinput_tablet_tool_config_pressure_range_get_default_maximum
* @see libinput_tablet_tool_config_pressure_range_get_default_maximum
*
* @since 1.26
*/
libinput_tablet_tool_config_pressure_range_get_maximum :: (tool: *libinput_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the minimum pressure value for this tablet tool, normalized to the
* range [0.0, 1.0] of the available hardware pressure.
*
* If the tool does not support pressure range configuration, the return value
* of this function is always 0.0.
*
* @param tool The libinput tool
* @return The minimum pressure value for this tablet tool
*
* @see libinput_tablet_tool_config_pressure_range_is_available
* @see libinput_tablet_tool_config_pressure_range_get_minimum
* @see libinput_tablet_tool_config_pressure_range_get_maximum
* @see libinput_tablet_tool_config_pressure_range_get_default_maximum
*
* @since 1.26
*/
libinput_tablet_tool_config_pressure_range_get_default_minimum :: (tool: *libinput_tablet_tool) -> float64 #foreign libinput_lib;

/**
* @ingroup config
*
* Get the maximum pressure value for this tablet tool, normalized to the
* range [0.0, 1.0] of the available hardware pressure.
*
* If the tool does not support pressure range configuration, the return value
* of this function is always 1.0.
*
* @param tool The libinput tool
* @return The maximum pressure value for this tablet tool
*
* @see libinput_tablet_tool_config_pressure_range_is_available
* @see libinput_tablet_tool_config_pressure_range_get_maximum
* @see libinput_tablet_tool_config_pressure_range_get_maximum
* @see libinput_tablet_tool_config_pressure_range_get_default_maximum
*
* @since 1.26
*/
libinput_tablet_tool_config_pressure_range_get_default_maximum :: (tool: *libinput_tablet_tool) -> float64 #foreign libinput_lib;

#scope_file

libinput_lib :: #library,system "libinput";
