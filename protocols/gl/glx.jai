//
// This file was autogenerated.
//



Bool :: s32;
Status :: s32;
True :: 1;
False :: 0;

XID :: u64;

_XDisplay :: struct {}
Display :: _XDisplay;

GLXFBConfigID :: XID;
__GLXFBConfigRec :: struct {}
GLXFBConfig :: *__GLXFBConfigRec;
GLXContextID :: XID;
__GLXcontextRec :: struct {}
GLXContext :: *__GLXcontextRec;
GLXPixmap :: XID;
GLXDrawable :: XID;
GLXWindow :: XID;
GLXPbuffer :: XID;
__GLXextFuncPtr :: #type () -> void #c_call;
GLXVideoCaptureDeviceNV :: XID;
GLXVideoDeviceNV :: u32;
GLXVideoSourceSGIX :: XID;
GLXFBConfigIDSGIX :: XID;
GLXFBConfigSGIX :: *__GLXFBConfigRec;
GLXPbufferSGIX :: XID;
GLXPbufferClobberEvent :: struct {
    event_type:  s32; /* GLX_DAMAGED or GLX_SAVED */
    draw_type:   s32; /* GLX_WINDOW or GLX_PBUFFER */
    serial:      u64; /* # of last request processed by server */
    send_event:  s32; /* true if this came for SendEvent request */
    display:     *Display; /* display the event was read from */
    drawable:    GLXDrawable; /* XID of Drawable */
    buffer_mask: u32; /* mask indicating which buffers are affected */
    aux_buffer:  u32; /* which aux buffer was affected */
    x:           s32;
    y:           s32;
    width:       s32;
    height:      s32;
    count:       s32; /* if nonzero, at least this many more */
}

GLXBufferSwapComplete :: struct {
    type:       s32;
    serial:     u64; /* # of last request processed by server */
    send_event: s32; /* true if this came from a SendEvent request */
    display:    *Display; /* Display the event was read from */
    drawable:   GLXDrawable; /* drawable on which event was requested in event mask */
    event_type: s32;
    ust:        s64;
    msc:        s64;
    sbc:        s64;
}

__GLXEvent :: union {
    glxpbufferclobber:     GLXPbufferClobberEvent;
    glxbufferswapcomplete: GLXBufferSwapComplete;
    pad:                   [24] s64;
}

GLXEvent :: __GLXEvent;
GLXStereoNotifyEventEXT :: struct {
    type:        s32;
    serial:      u64;
    send_event:  s32;
    display:     *Display;
    extension:   s32;
    evtype:      s32;
    window:      GLXDrawable;
    stereo_tree: s32;
}

GLXBufferClobberEventSGIX :: struct {
    type:       s32;
    serial:     u64; /* # of last request processed by server */
    send_event: s32; /* true if this came for SendEvent request */
    display:    *Display; /* display the event was read from */
    drawable:   GLXDrawable; /* i.d. of Drawable */
    event_type: s32; /* GLX_DAMAGED_SGIX or GLX_SAVED_SGIX */
    draw_type:  s32; /* GLX_WINDOW_SGIX or GLX_PBUFFER_SGIX */
    mask:       u32; /* mask indicating which buffers are affected*/
    x:          s32;
    y:          s32;
    width:      s32;
    height:     s32;
    count:      s32; /* if nonzero, at least this many more */
}

GLXHyperpipeNetworkSGIX :: struct {
    pipeName:  [80] u8; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    networkId: s32;
}

GLXHyperpipeConfigSGIX :: struct {
    pipeName:          [80] u8; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    channel:           s32;
    participationType: u32;
    timeSlice:         s32;
}

GLXPipeRect :: struct {
    pipeName:    [80] u8; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    srcXOrigin:  s32;
    srcYOrigin:  s32;
    srcWidth:    s32;
    srcHeight:   s32;
    destXOrigin: s32;
    destYOrigin: s32;
    destWidth:   s32;
    destHeight:  s32;
}

GLXPipeRectLimits :: struct {
    pipeName:  [80] u8; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
    XOrigin:   s32;
    YOrigin:   s32;
    maxHeight: s32;
    maxWidth:  s32;
}


// GLX_VERSION_1_0
GLX_EXTENSION_NAME :: &quot;GLX&quot;;  // This is modest abuse of the enum tag mechanism, maybe a string tag?
GLX_PbufferClobber :: 0;
GLX_BufferSwapComplete :: 1;
__GLX_NUMBER_EVENTS :: 17;
GLX_BAD_SCREEN :: 1;
GLX_BAD_ATTRIBUTE :: 2;
GLX_NO_EXTENSION :: 3;
GLX_BAD_VISUAL :: 4;
GLX_BAD_CONTEXT :: 5;
GLX_BAD_VALUE :: 6;
GLX_BAD_ENUM :: 7;
GLX_USE_GL :: 1;
GLX_BUFFER_SIZE :: 2;
GLX_LEVEL :: 3;
GLX_RGBA :: 4;
GLX_DOUBLEBUFFER :: 5;
GLX_STEREO :: 6;
GLX_AUX_BUFFERS :: 7;
GLX_RED_SIZE :: 8;
GLX_GREEN_SIZE :: 9;
GLX_BLUE_SIZE :: 10;
GLX_ALPHA_SIZE :: 11;
GLX_DEPTH_SIZE :: 12;
GLX_STENCIL_SIZE :: 13;
GLX_ACCUM_RED_SIZE :: 14;
GLX_ACCUM_GREEN_SIZE :: 15;
GLX_ACCUM_BLUE_SIZE :: 16;
GLX_ACCUM_ALPHA_SIZE :: 17;

// GLX_VERSION_1_1
GLX_VENDOR :: 0x1;
GLX_VERSION :: 0x2;
GLX_EXTENSIONS :: 0x3;

// GLX_VERSION_1_2

// GLX_VERSION_1_3
GLX_WINDOW_BIT :: 0x00000001;
GLX_PIXMAP_BIT :: 0x00000002;
GLX_PBUFFER_BIT :: 0x00000004;
GLX_RGBA_BIT :: 0x00000001;
GLX_COLOR_INDEX_BIT :: 0x00000002;
GLX_PBUFFER_CLOBBER_MASK :: 0x08000000;
GLX_FRONT_LEFT_BUFFER_BIT :: 0x00000001;
GLX_FRONT_RIGHT_BUFFER_BIT :: 0x00000002;
GLX_BACK_LEFT_BUFFER_BIT :: 0x00000004;
GLX_BACK_RIGHT_BUFFER_BIT :: 0x00000008;
GLX_AUX_BUFFERS_BIT :: 0x00000010;
GLX_DEPTH_BUFFER_BIT :: 0x00000020;
GLX_STENCIL_BUFFER_BIT :: 0x00000040;
GLX_ACCUM_BUFFER_BIT :: 0x00000080;
GLX_CONFIG_CAVEAT :: 0x20;
GLX_X_VISUAL_TYPE :: 0x22;
GLX_TRANSPARENT_TYPE :: 0x23;
GLX_TRANSPARENT_INDEX_VALUE :: 0x24;
GLX_TRANSPARENT_RED_VALUE :: 0x25;
GLX_TRANSPARENT_GREEN_VALUE :: 0x26;
GLX_TRANSPARENT_BLUE_VALUE :: 0x27;
GLX_TRANSPARENT_ALPHA_VALUE :: 0x28;
GLX_DONT_CARE :: 0xFFFFFFFF;  // For ChooseFBConfig attributes
GLX_NONE :: 0x8000;  // Attribute value
GLX_SLOW_CONFIG :: 0x8001;  // CONFIG_CAVEAT attribute value
GLX_TRUE_COLOR :: 0x8002;  // X_VISUAL_TYPE attribute value
GLX_DIRECT_COLOR :: 0x8003;  // X_VISUAL_TYPE attribute value
GLX_PSEUDO_COLOR :: 0x8004;  // X_VISUAL_TYPE attribute value
GLX_STATIC_COLOR :: 0x8005;  // X_VISUAL_TYPE attribute value
GLX_GRAY_SCALE :: 0x8006;  // X_VISUAL_TYPE attribute value
GLX_STATIC_GRAY :: 0x8007;  // X_VISUAL_TYPE attribute value
GLX_TRANSPARENT_RGB :: 0x8008;  // TRANSPARENT_TYPE attribute value
GLX_TRANSPARENT_INDEX :: 0x8009;  // TRANSPARENT_TYPE attribute value
GLX_VISUAL_ID :: 0x800B;  // Context attribute
GLX_SCREEN :: 0x800C;  // Context attribute
GLX_NON_CONFORMANT_CONFIG :: 0x800D;  // CONFIG_CAVEAT attribute value
GLX_DRAWABLE_TYPE :: 0x8010;  // FBConfig attribute
GLX_RENDER_TYPE :: 0x8011;  // FBConfig attribute
GLX_X_RENDERABLE :: 0x8012;  // FBConfig attribute
GLX_FBCONFIG_ID :: 0x8013;  // FBConfig attribute
GLX_RGBA_TYPE :: 0x8014;  // CreateNewContext render_type value
GLX_COLOR_INDEX_TYPE :: 0x8015;  // CreateNewContext render_type value
GLX_MAX_PBUFFER_WIDTH :: 0x8016;  // FBConfig attribute
GLX_MAX_PBUFFER_HEIGHT :: 0x8017;  // FBConfig attribute
GLX_MAX_PBUFFER_PIXELS :: 0x8018;  // FBConfig attribute
GLX_PRESERVED_CONTENTS :: 0x801B;  // CreateGLXPbuffer attribute
GLX_LARGEST_PBUFFER :: 0x801C;  // CreateGLXPbuffer attribute
GLX_WIDTH :: 0x801D;  // Drawable attribute
GLX_HEIGHT :: 0x801E;  // Drawable attribute
GLX_EVENT_MASK :: 0x801F;  // Drawable attribute
GLX_DAMAGED :: 0x8020;  // PbufferClobber event_type value
GLX_SAVED :: 0x8021;  // PbufferClobber event_type value
GLX_WINDOW :: 0x8022;  // PbufferClobber draw_type value
GLX_PBUFFER :: 0x8023;  // PbufferClobber draw_type value
GLX_PBUFFER_HEIGHT :: 0x8040;  // CreateGLXPbuffer attribute
GLX_PBUFFER_WIDTH :: 0x8041;  // CreateGLXPbuffer attribute

// GLX_VERSION_1_4
GLX_SAMPLE_BUFFERS :: 100000;
GLX_SAMPLES :: 100001;

GLX_Procs :: struct #type_info_procedures_are_void_pointers #type_info_no_size_complaint {
    // GLX_VERSION_1_0
    glXChooseVisual: #type (dpy: *Display, screen: int, attribList: *int) -> *XVisualInfo #c_call;
    glXCreateContext: #type (dpy: *Display, vis: *XVisualInfo, shareList: GLXContext, direct: Bool) -> GLXContext #c_call;
    glXDestroyContext: #type (dpy: *Display, ctx: GLXContext) #c_call;
    glXMakeCurrent: #type (dpy: *Display, drawable: GLXDrawable, ctx: GLXContext) -> Bool #c_call;
    glXCopyContext: #type (dpy: *Display, src: GLXContext, dst: GLXContext, mask: long) #c_call;
    glXSwapBuffers: #type (dpy: *Display, drawable: GLXDrawable) #c_call;
    glXCreateGLXPixmap: #type (dpy: *Display, visual: *XVisualInfo, pixmap: Pixmap) -> GLXPixmap #c_call;
    glXDestroyGLXPixmap: #type (dpy: *Display, pixmap: GLXPixmap) #c_call;
    glXQueryExtension: #type (dpy: *Display, errorb: *int, event: *int) -> Bool #c_call;
    glXQueryVersion: #type (dpy: *Display, maj: *int, min: *int) -> Bool #c_call;
    glXIsDirect: #type (dpy: *Display, ctx: GLXContext) -> Bool #c_call;
    glXGetConfig: #type (dpy: *Display, visual: *XVisualInfo, attrib: int, value: *int) -> int #c_call;
    glXGetCurrentContext: #type () -> GLXContext #c_call;
    glXGetCurrentDrawable: #type () -> GLXDrawable #c_call;
    glXWaitGL: #type () #c_call;
    glXWaitX: #type () #c_call;
    glXUseXFont: #type (font: Font, first: int, count: int, list: int) #c_call;

    // GLX_VERSION_1_1
    glXQueryExtensionsString: #type (dpy: *Display, screen: int) -> *u8 #c_call;
    glXQueryServerString: #type (dpy: *Display, screen: int, name: int) -> *u8 #c_call;
    glXGetClientString: #type (dpy: *Display, name: int) -> *u8 #c_call;

    // GLX_VERSION_1_2
    glXGetCurrentDisplay: #type () -> *Display #c_call;

    // GLX_VERSION_1_3
    glXGetFBConfigs: #type (dpy: *Display, screen: int, nelements: *int) -> *GLXFBConfig #c_call;
    glXChooseFBConfig: #type (dpy: *Display, screen: int, attrib_list: *int, nelements: *int) -> *GLXFBConfig #c_call;
    glXGetFBConfigAttrib: #type (dpy: *Display, config: GLXFBConfig, attribute: int, value: *int) -> int #c_call;
    glXGetVisualFromFBConfig: #type (dpy: *Display, config: GLXFBConfig) -> *XVisualInfo #c_call;
    glXCreateWindow: #type (dpy: *Display, config: GLXFBConfig, win: Window, attrib_list: *int) -> GLXWindow #c_call;
    glXDestroyWindow: #type (dpy: *Display, win: GLXWindow) #c_call;
    glXCreatePixmap: #type (dpy: *Display, config: GLXFBConfig, pixmap: Pixmap, attrib_list: *int) -> GLXPixmap #c_call;
    glXDestroyPixmap: #type (dpy: *Display, pixmap: GLXPixmap) #c_call;
    glXCreatePbuffer: #type (dpy: *Display, config: GLXFBConfig, attrib_list: *int) -> GLXPbuffer #c_call;
    glXDestroyPbuffer: #type (dpy: *Display, pbuf: GLXPbuffer) #c_call;
    glXQueryDrawable: #type (dpy: *Display, draw: GLXDrawable, attribute: int, value: *int) #c_call;
    glXCreateNewContext: #type (dpy: *Display, config: GLXFBConfig, render_type: int, share_list: GLXContext, direct: Bool) -> GLXContext #c_call;
    glXMakeContextCurrent: #type (dpy: *Display, draw: GLXDrawable, read: GLXDrawable, ctx: GLXContext) -> Bool #c_call;
    glXGetCurrentReadDrawable: #type () -> GLXDrawable #c_call;
    glXQueryContext: #type (dpy: *Display, ctx: GLXContext, attribute: int, value: *int) -> int #c_call;
    glXSelectEvent: #type (dpy: *Display, draw: GLXDrawable, event_mask: long) #c_call;
    glXGetSelectedEvent: #type (dpy: *Display, draw: GLXDrawable, event_mask: *long) #c_call;

    // GLX_VERSION_1_4
    glXGetProcAddress: #type (procName: *GLubyte) -> __GLXextFuncPtr #c_call; @gl_loader
}

GLX_Ext_Procs :: struct #type_info_procedures_are_void_pointers #type_info_no_size_complaint {}
